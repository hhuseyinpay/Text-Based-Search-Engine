Cartesian Coordinates in the Plane
In the previous section we identified the points on the line with real numbers by assigning
them coordinates. Points in the plane can be identified with ordered pairs of real numbers.
To begin, we draw two perpendicular coordinate lines that intersect at the 0-point of each
line. These lines are called coordinate axes in the plane. On the horizontal x-axis, numbers
are denoted by x and increase to the right. On the vertical y-axis, numbers are denoted
by y and increase upward (Figure 1.5). Thus “upward” and “to the right” are positive directions,
whereas “downward” and “to the left” are considered as negative. The origin O, also
labeled 0, of the coordinate system is the point in the plane where x and y are both zero.
If P is any point in the plane, it can be located by exactly one ordered pair of real numbers
in the following way. Draw lines through P perpendicular to the two coordinate axes.
These lines intersect the axes at points with coordinates a and b (Figure 1.5). The ordered
pair (a, b) is assigned to the point P and is called its coordinate pair. The first number a is
the x-coordinate (or abscissa) of P; the second number b is the y-coordinate (or
ordinate) of P. The x-coordinate of every point on the y-axis is 0. The y-coordinate of
every point on the x-axis is 0. The origin is the point (0, 0).
Starting with an ordered pair (a, b), we can reverse the process and arrive at a corresponding
point P in the plane. Often we identify P with the ordered pair and write P(a, b).
We sometimes also refer to “the point (a, b)” and it will be clear from the context when
(a, b) refers to a point in the plane and not to an open interval on the real line. Several
points labeled by their coordinates are shown in Figure 1.6.
This coordinate system is called the rectangular coordinate system or Cartesian
coordinate system (after the sixteenth century French mathematician René Descartes).
The coordinate axes of this coordinate or Cartesian plane divide the plane into four regions
called quadrants, numbered counterclockwise as shown in Figure 1.6.
The graph of an equation or inequality in the variables x and y is the set of all points
P(x, y) in the plane whose coordinates satisfy the equation or inequality. When we plot
data in the coordinate plane or graph formulas whose variables have different units of
measure, we do not need to use the same scale on the two axes. If we plot time vs. thrust
for a rocket motor, for example, there is no reason to place the mark that shows 1 sec on
the time axis the same distance from the origin as the mark that shows 1 lb on the thrust
axis.
Usually when we graph functions whose variables do not represent physical measurements
and when we draw figures in the coordinate plane to study their geometry and
trigonometry, we try to make the scales on the axes identical. A vertical unit of distance
then looks the same as a horizontal unit. As on a surveyor’s map or a scale drawing, line
segments that are supposed to have the same length will look as if they do and angles that
are supposed to be congruent will look congruent.
Computer displays and calculator displays are another matter. The vertical and horizontal
scales on machine-generated graphs usually differ, and there are corresponding distortions
in distances, slopes, and angles. Circles may look like ellipses, rectangles may
look like squares, right angles may appear to be acute or obtuse, and so on. We discuss
these displays and distortions in greater detail in Section 1.7.

Functions; Domain and Range
The temperature at which water boils depends on the elevation above sea level (the boiling
point drops as you ascend). The interest paid on a cash investment depends on the length of
time the investment is held. The area of a circle depends on the radius of the circle. The distance
an object travels from an initial location along a straight line path depends on its speed.
In each case, the value of one variable quantity, which we might call y, depends on the
value of another variable quantity, which we might call x. Since the value of y is completely
determined by the value of x, we say that y is a function of x. Often the value of y is
given by a rule or formula that says how to calculate it from the variable x. For instance,
the equation is a rule that calculates the area A of a circle from its radius r.
In calculus we may want to refer to an unspecified function without having any particular
formula in mind. A symbolic way to say “y is a function of x” is by writing
In this notation, the symbol ƒ represents the function. The letter x, called the independent
variable, represents the input value of ƒ, and y, the dependent variable, represents the
corresponding output value of ƒ at x.
The set D of all possible input values is called the domain of the function. The set of
all values of ƒ(x) as x varies throughout D is called the range of the function. The range
may not include every element in the set Y.
The domain and range of a function can be any sets of objects, but often in calculus
they are sets of real numbers. (In Chapters 13–16 many variables may be involved.)
Think of a function ƒ as a kind of machine that produces an output value ƒ(x) in its
range whenever we feed it an input value x from its domain (Figure 1.22). The function
keys on a calculator give an example of a function as a machine. For instance, the key
on a calculator gives an output value (the square root) whenever you enter a nonnegative
number x and press the key. The output value appearing in the display is usually a decimal
approximation to the square root of x. If you input a number then the calculator
will indicate an error because is not in the domain of the function and cannot be accepted
as an input. The key on a calculator is not the same as the exact mathematical
function ƒ defined by because it is limited to decimal outputs and has only finitely
many inputs.
A function can also be pictured as an arrow diagram (Figure 1.23). Each arrow
associates an element of the domain D to a unique or single element in the set Y. In Figure
1.23, the arrows indicate that ƒ(a) is associated with a, ƒ(x) is associated with x, and so on.
The domain of a function may be restricted by context. For example, the domain of
the area function given by only allows the radius r to be positive. When we define
a function with a formula and the domain is not stated explicitly or restricted
by context, the domain is assumed to be the largest set of real x-values for which
the formula gives real y-values, the so-called natural domain. If we want to restrict the
domain in some way, we must say so. The domain of is the entire set of real numbers.
To restrict the function to, say, positive values of x, we would write
Changing the domain to which we apply a formula usually changes the range as well.
The range of is The range of is the set of all numbers obtained
by squaring numbers greater than or equal to 2. In set notation, the range is
or or
When the range of a function is a set of real numbers, the function is said to be realvalued.
The domains and ranges of many real-valued functions of a real variable are intervals
or combinations of intervals. The intervals may be open, closed, or half open, and may
be finite or infinite.
Representing a Function Numerically
We have seen how a function may be represented algebraically by a formula (the area
function) and visually by a graph (Examples 2 and 3). Another way to represent a function
is numerically, through a table of values. Numerical representations are often used by engineers
and applied scientists. From an appropriate table of values, a graph of the function
can be obtained using the method illustrated in Example 2, possibly with the aid of a computer.
The graph of only the tabled points is called a scatterplot.
The Vertical Line Test
Not every curve you draw is the graph of a function. A function ƒ can have only one value
ƒ(x) for each x in its domain, so no vertical line can intersect the graph of a function more
than once. Thus, a circle cannot be the graph of a function since some vertical lines intersect
the circle twice (Figure 1.28a). If a is in the domain of a function ƒ, then the vertical
line will intersect the graph of ƒ in the single point (a, ƒ(a)).
The circle in Figure 1.28a, however, does contain the graphs of two functions of x; the
upper semicircle defined by the function and the lower semicircle defined
by the function gsxd = -21 - x2 (Figures 1.28b and 1.28c).
Before there were computers, there were algorithms. But now that there are computers,
there are even more algorithms, and algorithms lie at the heart of computing.
This book provides a comprehensive introduction to the modern study of computer
algorithms. It presents many algorithms and covers them in considerable
depth, yet makes their design and analysis accessible to all levels of readers. We
have tried to keep explanations elementary without sacrificing depth of coverage
or mathematical rigor.
Each chapter presents an algorithm, a design technique, an application area, or a
related topic. Algorithms are described in English and in a pseudocode designed to
be readable by anyone who has done a little programming. The book contains 244
figures—many with multiple parts—illustrating how the algorithms work. Since
we emphasize efficiency as a design criterion, we include careful analyses of the
running times of all our algorithms.
The text is intended primarily for use in undergraduate or graduate courses in
algorithms or data structures. Because it discusses engineering issues in algorithm
design, as well as mathematical aspects, it is equally well suited for self-study by
technical professionals.
In this, the third edition, we have once again updated the entire book. The
changes cover a broad spectrum, including new chapters, revised pseudocode, and
a more active writing style.
To the teacher
We have designed this book to be both versatile and complete. You should find it
useful for a variety of courses, from an undergraduate course in data structures up
through a graduate course in algorithms. Because we have provided considerably
more material than can fit in a typical one-term course, you can consider this book
to be a “buffet” or “smorgasbord” from which you can pick and choose the material
that best supports the course you wish to
You should find it easy to organize your course around just the chapters you
need. We have made chapters relatively self-contained, so that you need not worry
about an unexpected and unnecessary dependence of one chapter on another. Each
chapter presents the easier material first and the more difficult material later, with
section boundaries marking natural stopping points. In an undergraduate course,
you might use only the earlier sections from a chapter; in a graduate course, you
might cover the entire chapter.
We have included 957 exercises and 158 problems. Each section ends with exercises,
and each chapter ends with problems. The exercises are generally short questions
that test basic mastery of the material. Some are simple self-check thought
exercises, whereas others are more substantial and are suitable as assigned homework.
The problems are more elaborate case studies that often introduce new material;
they often consist of several questions that lead the student through the steps
required to arrive at a solution.
Departing from our practice in previous editions of this book, we have made
publicly available solutions to some, but by no means all, of the problems and exercises.
Our Web site, http://mitpress.mit.edu/algorithms/, links to these solutions.
You will want to check this site to make sure that it does not contain the solution to
an exercise or problem that you plan to assign. We expect the set of solutions that
we post to grow slowly over time, so you will need to check it each time you teach
the course.
We have starred (?) the sections and exercises that are more suitable for graduate
students than for undergraduates. A starred section is not necessarily more difficult
than an unstarred one, but it may require an understanding of more advanced
mathematics. Likewise, starred exercises may require an advanced background or
more than average creativity.
To the student
We hope that this textbook provides you with an enjoyable introduction to the
field of algorithms. We have attempted to make every algorithm accessible and
interesting. To help you when you encounter unfamiliar or difficult algorithms, we
describe each one in a step-by-step manner. We also provide careful explanations
of the mathematics needed to understand the analysis of the algorithms. If you
already have some familiarity with a topic, you will find the chapters organized so
that you can skim introductory sections and proceed quickly to the more advanced
material.
This is a large book, and your class will probably cover only a portion of its
material. We have tried, however, to make this a book that will be useful to you
now as a course textbook and also later in your career as a mathematical desk
reference or an engineering handbook.
What are the prerequisites for reading this book?
 You should have some programming experience. In particular, you should understand
recursive procedures and simple data structures such as arrays and
linked lists.
 You should have some facility with mathematical proofs, and especially proofs
by mathematical induction. A few portions of the book rely on some knowledge
of elementary calculus. Beyond that, Parts I and VIII of this book teach you all
the mathematical techniques you will need.
We have heard, loud and clear, the call to supply solutions to problems and
exercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to solutions for
a few of the problems and exercises. Feel free to check your solutions against ours.
We ask, however, that you do not send your solutions to us.
To the professional
The wide range of topics in this book makes it an excellent handbook on algorithms.
Because each chapter is relatively self-contained, you can focus in on the
topics that most interest you.
Most of the algorithms we discuss have great practical utility. We therefore
address implementation concerns and other engineering issues. We often provide
practical alternatives to the few algorithms that are primarily of theoretical interest.
If you wish to implement any of the algorithms, you should find the translation
of our pseudocode into your favorite programming language to be a fairly
straightforward task. We have designed the pseudocode to present each algorithm
clearly and succinctly. Consequently, we do not address error-handling and other
software-engineering issues that require specific assumptions about your programming
environment. We attempt to present each algorithm simply and directly without
allowing the idiosyncrasies of a particular programming language to obscure
its essence.
We understand that if you are using this book outside of a course, then you
might be unable to check your solutions to problems and exercises against solutions
provided by an instructor. Our Web site, http://mitpress.mit.edu/algorithms/, links
to solutions for some of the problems and exercises so that you can check your
work. Please do not send your solutions to us.
To our colleagues
We have supplied an extensive bibliography and pointers to the current literature.
Each chapter ends with a set of chapter notes that give historical details and references.
The chapter notes do not provide a complete reference to the whole field
of algorithms, however. Though it may be hard to believe for a book of this size,
space constraints prevented us from including many interesting algorithms.
Despite myriad requests from students for solutions to problems and exercises,
we have chosen as a matter of policy not to supply references for problems and
exercises, to remove the temptation for students to look up a solution rather than to
find it themselves.
Changes for the third edition
What has changed between the second and third editions of this book? The magnitude
of the changes is on a par with the changes between the first and second
editions. As we said about the second-edition changes, depending on how you
look at it, the book changed either not much or quite a bit.
A quick look at the table of contents shows that most of the second-edition chapters
and sections appear in the third edition. We removed two chapters and one
section, but we have added three new chapters and two new sections apart from
these new chapters.
We kept the hybrid organization from the first two editions. Rather than organizing
chapters by only problem domains or according only to techniques, this book
has elements of both. It contains technique-based chapters on divide-and-conquer,
dynamic programming, greedy algorithms, amortized analysis, NP-Completeness,
and approximation algorithms. But it also has entire parts on sorting, on data
structures for dynamic sets, and on algorithms for graph problems. We find that
although you need to know how to apply techniques for designing and analyzing algorithms,
problems seldom announce to you which techniques are most amenable
to solving them.
Here is a summary of the most significant changes for the third edition:
 We added new chapters on van Emde Boas trees and multithreaded algorithms,
and we have broken out material on matrix basics into its own appendix chapter.
 We revised the chapter on recurrences to more broadly cover the divide-andconquer
technique, and its first two sections apply divide-and-conquer to solve
two problems. The second section of this chapter presents Strassen’s algorithm
for matrix multiplication, which we have moved from the chapter on matrix
operations.
 We removed two chapters that were rarely taught: binomial heaps and sorting
networks. One key idea in the sorting networks chapter, the 0-1 principle, appears
in this edition within Problem 8-7 as the 0-1 sorting lemma for compareexchange
algorithms. The treatment of Fibonacci heaps no longer relies on
binomial heaps as a precursor.
We revised our treatment of dynamic programming and greedy algorithms. Dynamic
programming now leads off with a more interesting problem, rod cutting,
than the assembly-line scheduling problem from the second edition. Furthermore,
we emphasize memoization a bit more than we did in the second edition,
and we introduce the notion of the subproblem graph as a way to understand
the running time of a dynamic-programming algorithm. In our opening example
of greedy algorithms, the activity-selection problem, we get to the greedy
algorithm more directly than we did in the second edition.
 The way we delete a node from binary search trees (which includes red-black
trees) now guarantees that the node requested for deletion is the node that is
actually deleted. In the first two editions, in certain cases, some other node
would be deleted, with its contents moving into the node passed to the deletion
procedure. With our new way to delete nodes, if other components of a program
maintain pointers to nodes in the tree, they will not mistakenly end up with stale
pointers to nodes that have been deleted.
 The material on flow networks now bases flows entirely on edges. This approach
is more intuitive than the net flow used in the first two editions.
 With the material on matrix basics and Strassen’s algorithm moved to other
chapters, the chapter on matrix operations is smaller than in the second edition.
 We have modified our treatment of the Knuth-Morris-Pratt string-matching algorithm.
 We corrected several errors. Most of these errors were posted on our Web site
of second-edition errata, but a few were not.
 Based on many requests, we changed the syntax (as it were) of our pseudocode.
We now use “D” to indicate assignment and “==” to test for equality, just as C,
C++, Java, and Python do. Likewise, we have eliminated the keywords do and
then and adopted “//” as our comment-to-end-of-line symbol. We also now use
dot-notation to indicate object attributes. Our pseudocode remains procedural,
rather than object-oriented. In other words, rather than running methods on
objects, we simply call procedures, passing objects as parameters.
 We added 100 new exercises and 28 new problems. We also updated many
bibliography entries and added several new ones.
 Finally, we went through the entire book and rewrote sentences, paragraphs,
and sections to make the writing clearer and more active.
Web site
You can use our Web site, http://mitpress.mit.edu/algorithms/, to obtain supplementary
information and to communicate with us. The Web site links to a list of
known errors, solutions to selected exercises and problems, and (of course) a list
explaining the corny professor jokes, as well as other content that we might add.
The Web site also tells you how to report errors or make suggestions.
How we produced this book
Like the second edition, the third edition was produced in LATEX2". We used the
Times font with mathematics typeset using the MathTime Pro 2 fonts. We thank
Michael Spivak from Publish or Perish, Inc., Lance Carnes from Personal TeX,
Inc., and Tim Tregubov from Dartmouth College for technical support. As in the
previous two editions, we compiled the index using Windex, a C program that we
wrote, and the bibliography was produced with BIBTEX. The PDF files for this
book were created on a MacBook running OS 10.5.
We drew the illustrations for the third edition using MacDraw Pro, with some
of the mathematical expressions in illustrations laid in with the psfrag package
for LATEX2". Unfortunately, MacDraw Pro is legacy software, having not been
marketed for over a decade now. Happily, we still have a couple of Macintoshes
that can run the Classic environment under OS 10.4, and hence they can run Mac-
Draw Pro—mostly. Even under the Classic environment, we find MacDraw Pro to
be far easier to use than any other drawing software for the types of illustrations
that accompany computer-science text, and it produces beautiful output.1 Who
knows how long our pre-Intel Macs will continue to run, so if anyone from Apple
is listening: Please create an OS X-compatible version of MacDraw Pro!
Acknowledgments for the third edition
We have been working with the MIT Press for over two decades now, and what a
terrific relationship it has been! We thank Ellen Faran, Bob Prior, Ada Brunstein,
and Mary Reilly for their help and support.
We were geographically distributed while producing the third edition, working
in the Dartmouth College Department of Computer Science, the MIT Computer
Science and Artificial Intelligence Laboratory, and the Columbia University Department
of Industrial Engineering and Operations Research. We thank our respective
universities and colleagues for providing such supportive and stimulating
environments.
Julie Sussman, P.P.A., once again bailed us out as the technical copyeditor. Time
and again, we were amazed at the errors that eluded us, but that Julie caught. She
also helped us improve our presentation in several places. If there is a Hall of Fame
for technical copyeditors, Julie is a sure-fire, first-ballot inductee. She is nothing
short of phenomenal. Thank you, thank you, thank you, Julie! Priya Natarajan also
found some errors that we were able to correct before this book went to press. Any
errors that remain (and undoubtedly, some do) are the responsibility of the authors
(and probably were inserted after Julie read the material).
The treatment for van Emde Boas trees derives from Erik Demaine’s notes,
which were in turn influenced by Michael Bender. We also incorporated ideas
from Javed Aslam, Bradley Kuszmaul, and Hui Zha into this edition.
The chapter on multithreading was based on notes originally written jointly with
Harald Prokop. The material was influenced by several others working on the Cilk
project at MIT, including Bradley Kuszmaul and Matteo Frigo. The design of the
multithreaded pseudocode took its inspiration from the MIT Cilk extensions to C
and by Cilk Arts’s Cilk++ extensions to C++.
We also thank the many readers of the first and second editions who reported
errors or submitted suggestions for how to improve this book. We corrected all the
bona fide errors that were reported, and we incorporated as many suggestions as
we could. We rejoice that the number of such contributors has grown so great that
we must regret that it has become impractical to list them all.
Finally, we thank our wives—Nicole Cormen, Wendy Leiserson, Gail Rivest,
and Rebecca Ivry—and our children—Ricky, Will, Debby, and Katie Leiserson;
Alex and Christopher Rivest; and Molly, Noah, and Benjamin Stein—for their love
and support while we prepared this book. The patience and encouragement of our
families made this project possible. We affectionately dedicate this book to them.
This part will start you thinking about designing and analyzing algorithms. It is
intended to be a gentle introduction to how we specify algorithms, some of the
design strategies we will use throughout this book, and many of the fundamental
ideas used in algorithm analysis. Later parts of this book will build upon this base.
Chapter 1 provides an overview of algorithms and their place in modern computing
systems. This chapter defines what an algorithm is and lists some examples.
It also makes a case that we should consider algorithms as a technology, alongside
technologies such as fast hardware, graphical user interfaces, object-oriented
systems, and networks.
In Chapter 2, we see our first algorithms, which solve the problem of sorting
a sequence of n numbers. They are written in a pseudocode which, although not
directly translatable to any conventional programming language, conveys the structure
of the algorithm clearly enough that you should be able to implement it in the
language of your choice. The sorting algorithms we examine are insertion sort,
which uses an incremental approach, and merge sort, which uses a recursive technique
known as “divide-and-conquer.” Although the time each requires increases
with the value of n, the rate of increase differs between the two algorithms. We
determine these running times in Chapter 2, and we develop a useful notation to
express them.
Chapter 3 precisely defines this notation, which we call asymptotic notation. It
starts by defining several asymptotic notations, which we use for bounding algorithm
running times from above and/or below. The rest of Chapter 3 is primarily
a presentation of mathematical notation, more to ensure that your use of notation
matches that in this book than to teach you new mathematical concepts.
Chapter 4 delves further into the divide-and-conquer method introduced in
Chapter 2. It provides additional examples of divide-and-conquer algorithms, including
Strassen’s surprising method for multiplying two square matrices. Chapter
4 contains methods for solving recurrences, which are useful for describing
the running times of recursive algorithms. One powerful technique is the “master
method,” which we often use to solve recurrences that arise from divide-andconquer
algorithms. Although much of Chapter 4 is devoted to proving the correctness
of the master method, you may skip this proof yet still employ the master
method.
Chapter 5 introduces probabilistic analysis and randomized algorithms. We typically
use probabilistic analysis to determine the running time of an algorithm in
cases in which, due to the presence of an inherent probability distribution, the
running time may differ on different inputs of the same size. In some cases, we
assume that the inputs conform to a known probability distribution, so that we are
averaging the running time over all possible inputs. In other cases, the probability
distribution comes not from the inputs but from random choices made during the
course of the algorithm. An algorithm whose behavior is determined not only by its
input but by the values produced by a random-number generator is a randomized
algorithm. We can use randomized algorithms to enforce a probability distribution
on the inputs—thereby ensuring that no particular input always causes poor performance—
or even to bound the error rate of algorithms that are allowed to produce
incorrect results on a limited basis.
Appendices A–D contain other mathematical material that you will find helpful
as you read this book. You are likely to have seen much of the material in the
appendix chapters before having read this book (although the specific definitions
and notational conventions we use may differ in some cases from what you have
seen in the past), and so you should think of the Appendices as reference material.
On the other hand, you probably have not already seen most of the material in
Part I. All the chapters in Part I and the Appendices are written with a tutorial
flavor.
Informally, an algorithm is any well-defined computational procedure that takes
some value, or set of values, as input and produces some value, or set of values, as
output. An algorithm is thus a sequence of computational steps that transform the
input into the output.
We can also view an algorithm as a tool for solving a well-specified computational
problem. The statement of the problem specifies in general terms the desired
input/output relationship. The algorithm describes a specific computational procedure
for achieving that input/output relationship.
For example, we might need to sort a sequence of numbers into nondecreasing
order. This problem arises frequently in practice and provides fertile ground for
introducing many standard design techniques and analysis tools. Here is how we
formally define the sorting problem:
Input: A sequence of n numbers ha1; a2; : : : ;ani.
Output: A permutation (reordering) ha0

For example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm
returns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is
called an instance of the sorting problem. In general, an instance of a problem
consists of the input (satisfying whatever constraints are imposed
Because many programs use it as an intermediate step, sorting is a fundamental
operation in computer science. As a result, we have a large number of good sorting
algorithms at our disposal. Which algorithm is best for a given application depends
on—among other factors—the number of items to be sorted, the extent to which
the items are already somewhat sorted, possible restrictions on the item values,
the architecture of the computer, and the kind of storage devices to be used: main
memory, disks, or even tapes.
An algorithm is said to be correct if, for every input instance, it halts with the
correct output. We say that a correct algorithm solves the given computational
problem. An incorrect algorithm might not halt at all on some input instances, or it
might halt with an incorrect answer. Contrary to what you might expect, incorrect
algorithms can sometimes be useful, if we can control their error rate. We shall see
an example of an algorithm with a controllable error rate in Chapter 31 when we
study algorithms for finding large prime numbers. Ordinarily, however, we shall
be concerned only with correct algorithms.
An algorithm can be specified in English, as a computer program, or even as
a hardware design. The only requirement is that the specification must provide a
precise description of the computational procedure to be followed.
What kinds of problems are solved by algorithms?
Sorting is by no means the only computational problem for which algorithms have
been developed. (You probably suspected as much when you saw the size of this
book.) Practical applications of algorithms are ubiquitous and include the following
examples:
 The Human Genome Project has made great progress toward the goals of identifying
all the 100,000 genes in human DNA, determining the sequences of the
3 billion chemical base pairs that make up human DNA, storing this information
in databases, and developing tools for data analysis. Each of these steps
requires sophisticated algorithms. Although the solutions to the various problems
involved are beyond the scope of this book, many methods to solve these
biological problems use ideas from several of the chapters in this book, thereby
enabling scientists to accomplish tasks while using resources efficiently. The
savings are in time, both human and machine, and in money, as more information
can be extracted from laboratory techniques.
 The Internet enables people all around the world to quickly access and retrieve
large amounts of information. With the aid of clever algorithms, sites on the
Internet are able to manage and manipulate this large volume of data. Examples
of problems that make essential use of algorithms include finding good routes
on which the data will travel (techniques for solving such problems appear in
Chapter 24), and using a search engine to quickly find pages on which particular
information resides (related techniques are in Chapters 11 and 32).
 Electronic commerce enables goods and services to be negotiated and exchanged
electronically, and it depends on the privacy of personal information
such as credit card numbers, passwords, and bank statements. The core
technologies used in electronic commerce include public-key cryptography and
digital signatures (covered in Chapter 31), which are based on numerical algorithms
and number theory.
 Manufacturing and other commercial enterprises often need to allocate scarce
resources in the most beneficial way. An oil company may wish to know where
to place its wells in order to maximize its expected profit. A political candidate
may want to determine where to spend money buying campaign advertising in
order to maximize the chances of winning an election. An airline may wish
to assign crews to flights in the least expensive way possible, making sure that
each flight is covered and that government regulations regarding crew scheduling
are met. An Internet service provider may wish to determine where to place
additional resources in order to serve its customers more effectively. All of
these are examples of problems that can be solved using linear programming,
which we shall study in Chapter 29.
Although some of the details of these examples are beyond the scope of this
book, we do give underlying techniques that apply to these problems and problem
areas. We also show how to solve many specific problems, including the following:
 We are given a road map on which the distance between each pair of adjacent
intersections is marked, and we wish to determine the shortest route from one
intersection to another. The number of possible routes can be huge, even if we
disallow routes that cross over themselves. How do we choose which of all
possible routes is the shortest? Here, we model the road map (which is itself
a model of the actual roads) as a graph (which we will meet in Part VI and
Appendix B), and we wish to find the shortest path from one vertex to another
in the graph. We shall see how to solve this problem efficiently in Chapter 24.
 We are given two ordered sequences of symbols, X D hx1; x2; : : : ; xmi and
Y D hy1; y2; : : : ; yni, and we wish to find a longest common subsequence of
X and Y . A subsequence of X is just X with some (or possibly all or none) of
its elements removed. For example, one subsequence of hA;B;C;D;E;F;Gi
would be hB; C; E; Gi. The length of a longest common subsequence of X
and Y gives one measure of how similar these two sequences are. For example,
if the two sequences are base pairs in DNA strands, then we might consider
them similar if they have a long common subsequence. If X has m symbols
and Y has n symbols, then X and Y have 2m and 2n possible subsequences,
respectively. Selecting all possible subsequences of X and Y and matching
them up could take a prohibitively long time unless m and n are very small.
We shall see in Chapter 15 how to use a general technique known as dynamic
programming to solve this problem much more efficiently.
 We are given a mechanical design in terms of a library of parts, where each part
may include instances of other parts, and we need to list the parts in order so
that each part appears before any part that uses it. If the design comprises n
parts, then there are nŠ possible orders, where nŠ denotes the factorial function.
Because the factorial function grows faster than even an exponential function,
we cannot feasibly generate each possible order and then verify that, within
that order, each part appears before the parts using it (unless we have only a
few parts). This problem is an instance of topological sorting, and we shall see
in Chapter 22 how to solve this problem efficiently.
 We are given n points in the plane, and we wish to find the convex hull of
these points. The convex hull is the smallest convex polygon containing the
points. Intuitively, we can think of each point as being represented by a nail
sticking out from a board. The convex hull would be represented by a tight
rubber band that surrounds all the nails. Each nail around which the rubber
band makes a turn is a vertex of the convex hull. (See Figure 33.6 on page 1029
for an example.) Any of the 2n subsets of the points might be the vertices
of the convex hull. Knowing which points are vertices of the convex hull is
not quite enough, either, since we also need to know the order in which they
appear. There are many choices, therefore, for the vertices of the convex hull.
Chapter 33 gives two good methods for finding the convex hull.
These lists are far from exhaustive (as you again have probably surmised from
this book’s heft), but exhibit two characteristics that are common to many interesting
algorithmic problems:
1. They have many candidate solutions, the overwhelming majority of which do
not solve the problem at hand. Finding one that does, or one that is “best,” can
present quite a challenge.
2. They have practical applications. Of the problems in the above list, finding the
shortest path provides the easiest examples. A transportation firm, such as a
trucking or railroad company, has a financial interest in finding shortest paths
through a road or rail network because taking shorter paths results in lower
labor and fuel costs. Or a routing node on the Internet may need to find the
shortest path through the network in order to route a message quickly. Or a
person wishing to drive from New York to Boston may want to find driving
directions from an appropriate Web site, or she may use her GPS while driving.
Not every problem solved by algorithms has an easily identified set of candidate
solutions. For example, suppose we are given a set of numerical values representing
samples of a signal, and we want to compute the discrete Fourier transform of
these samples. The discrete Fourier transform converts the time domain to the frequency
domain, producing a set of numerical coefficients, so that we can determine
the strength of various frequencies in the sampled signal. In addition to lying at
the heart of signal processing, discrete Fourier transforms have applications in data
compression and multiplying large polynomials and integers. Chapter 30 gives
an efficient algorithm, the fast Fourier transform (commonly called the FFT), for
this problem, and the chapter also sketches out the design of a hardware circuit to
compute the FFT.
Data structures
This book also contains several data structures. A data structure is a way to store
and organize data in order to facilitate access and modifications. No single data
structure works well for all purposes, and so it is important to know the strengths
and limitations of several of them.
Technique
Although you can use this book as a “cookbook” for algorithms, you may someday
encounter a problem for which you cannot readily find a published algorithm (many
of the exercises and problems in this book, for example). This book will teach you
techniques of algorithm design and analysis so that you can develop algorithms on
your own, show that they give the correct answer, and understand their efficiency.
Different chapters address different aspects of algorithmic problem solving. Some
chapters address specific problems, such as finding medians and order statistics in
Chapter 9, computing minimum spanning trees in Chapter 23, and determining a
maximum flow in a network in Chapter 26. Other chapters address techniques,
such as divide-and-conquer in Chapter 4, dynamic programming in Chapter 15,
and amortized analysis in Chapter 17.
Hard problems
Most of this book is about efficient algorithms. Our usual measure of efficiency
is speed, i.e., how long an algorithm takes to produce its result. There are some
problems, however, for which no efficient solution is known. Chapter 34 studies
an interesting subset of these problems, which are known as NP-complete.
Why are NP-complete problems interesting? First, although no efficient algorithm
for an NP-complete problem has ever been found, nobody has ever proven
that an efficient algorithm for one cannot exist. In other words, no one knows
whether or not efficient algorithms exist for NP-complete problems. Second, the
set of NP-complete problems has the remarkable property that if an efficient algorithm
exists for any one of them, then efficient algorithms exist for all of them. This
relationship among the NP-complete problems makes the lack of efficient solutions
all the more tantalizing. Third, several NP-complete problems are similar, but not
identical, to problems for which we do know of efficient algorithms. Computer
scientists are intrigued by how a small change to the problem statement can cause
a big change to the efficiency of the best known algorithm.
You should know about NP-complete problems because some of them arise surprisingly
often in real applications. If you are called upon to produce an efficient
algorithm for an NP-complete problem, you are likely to spend a lot of time in a
fruitless search. If you can show that the problem is NP-complete, you can instead
spend your time developing an efficient algorithm that gives a good, but not the
best possible, solution.
As a concrete example, consider a delivery company with a central depot. Each
day, it loads up each delivery truck at the depot and sends it around to deliver goods
to several addresses. At the end of the day, each truck must end up back at the depot
so that it is ready to be loaded for the next day. To reduce costs, the company wants
to select an order of delivery stops that yields the lowest overall distance traveled
by each truck. This problem is the well-known “traveling-salesman problem,” and
it is NP-complete. It has no known efficient algorithm. Under certain assumptions,
however, we know of efficient algorithms that give an overall distance which is
not too far above the smallest possible. Chapter 35 discusses such “approximation
algorithms.”
Parallelism
For many years, we could count on processor clock speeds increasing at a steady
rate. Physical limitations present a fundamental roadblock to ever-increasing clock
speeds, however: because power density increases superlinearly with clock speed,
chips run the risk of melting once their clock speeds become high enough. In order
to perform more computations per second, therefore, chips are being designed to
contain not just one but several processing “cores.” We can liken these multicore
computers to several sequential computers on a single chip; in other words, they are
a type of “parallel computer.” In order to elicit the best performance from multicore
computers, we need to design algorithms with parallelism in mind. Chapter 27
presents a model for “multithreaded” algorithms, which take advantage of multiple
cores. This model has advantages from a theoretical standpoint, and it forms the
basis of several successful computer programs, including a championship chess
program.
Algorithms as a technology
Suppose computers were infinitely fast and computer memory was free. Would
you have any reason to study algorithms? The answer is yes, if for no other reason
than that you would still like to demonstrate that your solution method terminates
and does so with the correct answer.
If computers were infinitely fast, any correct method for solving a problem
would do. You would probably want your implementation to be within the bounds
of good software engineering practice (for example, your implementation should
be well designed and documented), but you would most often use whichever
method was the easiest to implement.
Of course, computers may be fast, but they are not infinitely fast. And memory
may be inexpensive, but it is not free. Computing time is therefore a bounded
resource, and so is space in memory. You should use these resources wisely, and
algorithms that are efficient in terms of time or space will help you do so.
Efficiency
Different algorithms devised to solve the same problem often differ dramatically in
their efficiency. These differences can be much more significant than differences
due to hardware and software.
As an example, in Chapter 2, we will see two algorithms for sorting. The first,
known as insertion sort, takes time roughly equal to c1n2 to sort n items, where c1
is a constant that does not depend on n. That is, it takes time roughly proportional
to n2. The second, merge sort, takes time roughly equal to c2n lg n, where lg n
stands for log2 n and c2 is another constant that also does not depend on n. Insertion
sort typically has a smaller constant factor than merge sort, so that c1 < c2.
We shall see that the constant factors can have far less of an impact on the running
time than the dependence on the input size n. Let’s write insertion sort’s running
time as c1n  n and merge sort’s running time as c2n  lg n. Then we see that where
insertion sort has a factor of n in its running time, merge sort has a factor of lg n,
which is much smaller. (For example, when n D 1000, lgn is approximately 10,
and when n equals one million, lg n is approximately only 20.) Although insertion
sort usually runs faster than merge sort for small input sizes, once the input size n
becomes large enough, merge sort’s advantage of lg n vs. n will more than compensate
for the difference in constant factors. No matter how much smaller c1 is
than c2, there will always be a crossover point beyond which merge sort is faster.
For a concrete example, let us pit a faster computer (computer A) running insertion
sort against a slower computer (computer B) running merge sort. They each
must sort an array of 10 million numbers. (Although 10 million numbers might
seem like a lot, if the numbers are eight-byte integers, then the input occupies
about 80 megabytes, which fits in the memory of even an inexpensive laptop computer
many times over.) Suppose that computer A executes 10 billion instructions
per second (faster than any single sequential computer at the time of this writing)
and computer B executes only 10 million instructions per second, so that computer
A is 1000 times faster than computer B in raw computing power. To make
the difference even more dramatic, suppose that the world’s craftiest programmer
codes insertion sort in machine language for computer A, and the resulting code
requires 2n2 instructions to sort n numbers. Suppose further that just an average
programmer implements merge sort, using a high-level language with an inefficient
compiler, with the resulting code taking 50n lg n instructions. To sort 10 million
numbers, computer A takes
Algorithms and other technologies
The example above shows that we should consider algorithms, like computer hardware,
as a technology. Total system performance depends on choosing efficient
algorithms as much as on choosing fast hardware. Just as rapid advances are being
made in other computer technologies, they are being made in algorithms as well.
You might wonder whether algorithms are truly that important on contemporary
computers in light of other advanced technologies, such as
 advanced computer architectures and fabrication technologies,
 easy-to-use, intuitive, graphical user interfaces (GUIs),
 object-oriented systems,
 integrated Web technologies, and
 fast networking, both wired and wireless.
The answer is yes. Although some applications do not explicitly require algorithmic
content at the application level (such as some simple,Web-based applications),
many do. For example, consider aWeb-based service that determines how to travel
from one location to another. Its implementation would rely on fast hardware, a
graphical user interface, wide-area networking, and also possibly on object orientation.
However, it would also require algorithms for certain operations, such
as finding routes (probably using a shortest-path algorithm), rendering maps, and
interpolating addresses.
Moreover, even an application that does not require algorithmic content at the
application level relies heavily upon algorithms. Does the application rely on fast
hardware? The hardware design used algorithms. Does the application rely on
graphical user interfaces? The design of any GUI relies on algorithms. Does the
application rely on networking? Routing in networks relies heavily on algorithms.
Was the application written in a language other than machine code? Then it was
processed by a compiler, interpreter, or assembler, all of which make extensive use
of algorithms. Algorithms are at the core of most technologies used in contemporary
computers.
Furthermore, with the ever-increasing capacities of computers, we use them to
solve larger problems than ever before. As we saw in the above comparison between
insertion sort and merge sort, it is at larger problem sizes that the differences
in efficiency between algorithms become particularly prominent.
Having a solid base of algorithmic knowledge and technique is one characteristic
that separates the truly skilled programmers from the novices. With modern computing
technology, you can accomplish some tasks without knowing much about
algorithms, but with a good background in algorithms, you can do much, much
more.
This chapter will familiarize you with the framework we shall use throughout the
book to think about the design and analysis of algorithms. It is self-contained, but
it does include several references to material that we introduce in Chapters 3 and 4.
