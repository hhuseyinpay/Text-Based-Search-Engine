Field Description
rs Indicates that the vulnerability could lead to root access on the target system
us Indicates that a user shell could be invoked
ns Indicates that a shell owned by the nobody (uid = 2) user could be invoked
uw Indicates that the vulnerability could lead to the writing of a file as a nonroot
user
nr Indicates that the vulnerability could lead to a file read as the nobody user
The SATAN documentation does not mention three other listings that are used: x, l, and nw.
The l severity corresponds to login information gathered from rusers.satan and finger.satan.
The x entry indicates an unknown severity, but with potential for access. The nw indicates that
the nobody user can write files.
The ns entry corresponds to ITL class 6; the nr entry corresponds to ITL class 4; and the
others (except x and l) correspond to ITL class 5. (Note that permissions corresponding to the
nobody user directly relate to world access settings on files.) SATAN breaks down the ITL class
5 group into three parts: the ability to execute a program as any non-root user; the ability to
execute a program as the nobody user; and the ability to write files as any non-root user.
In general, if a hacker can modify any non-root user file, the hacker can modify executables
that the user will run, resulting in the ability of the hacker to gain execution access. The
nobody user concept is quite closely linked with the holes of NFS only.
Trusted ($trusted)
This field consists of two tokens separated by an @—the left part being a user and the right
part being a host. (If no @ is included, the entire field is interpreted as the user part.) It
represents an account or directory that trusts another target. The user part of that account is
selected from these four choices: user, root, nobody, or ANY. The host part can be either the
target system or ANY, but only the target system makes sense for the Trusted field. The
$trusted account trusts users as specified by the $trustee field.
Trustee ($trustee)
This field represents those users and systems that are trusted by the accounts listed in the
$trusted field. It uses the same format as the $trusted field.
Canonical Service Output ($canonical)
For non-vulnerability records, this contains a formatted version of the information, either user
name, home dir, last login or filesys, clients. For vulnerability records, this contains a description
of the problem type.
528 Part II: Gaining Access and Securing the Gateway
Text ($text)
This contains messages used for reports. For example, for a TCP scan, this field contains offers
<service>, where <service> corresponds to a service name from the /etc/services file, such as
shell.
Sample Fact Record
Here is an example of the output of the rpc.satan scan that consists of records in the fact
database record format:
% bin/ftp.satan m2.notreal.com
m2|ftp|a|x|||ANONYMOUS|offers anon ftp
m2|ftp|a|nw|˜ftp|ANY@ANY|writable FTP home directory|˜ftp is writable
%
Both facts have a $target of m2, a $service of ftp, and indicate a $status of a (available). The
$severity field for the first record is x, indicating an informational record with unknown
severity, whereas the second record shows nw to indicate that anyone (even the nobody user)
can write a file using this vulnerability. The $trusted and $trustee fields do not apply to the
first record, but the second record indicates that the ˜ftp directory ($trusted) grants access to
anyone on any other system ($trustee = ANY@ANY). The canonical service output for the first
record indicates that the problem is ANONYMOUS access to FTP, whereas the second record
indicates the problem is a “writable FTP home directory.” Finally, the $text fields for both
records describe the problem for reporting purposes.
Note The pathnames of most of the .satan tools assume that they are being run with a
default directory of the top-level SATAN program, satan-1.1.1. For example,
rpc.satan tries to include config/paths.pl, where config is a subdirectory of satan-
1.1.1. Either run these tools from that directory, as shown in the example, or modify
these tools to include absolute pathnames.
Another way to understand the facts database is to look at the actual satan-1.1.1/results/satandata/
facts file after running a few heavy scans. This file will be filled with records generated by
the .satan tools.
Seeing All the Hosts
The all-hosts text file contains host records, which are used to keep track of hosts that SATAN
has seen, regardless of whether these hosts have been scanned by SATAN. Each host record
consists of six fields, each separated by a pipe (|) character. Newlines separate entries in this
file.
SATAN and the Internet Inferno 529
Each SATAN host record consists of the following six fields:
n The name of the host
n The IP address of the host
n The proximity level from the original target
n The level to which this host has been scanned (-1 for hosts that have not been scanned)
n Whether this host was encountered during subnet expansion (0 for no, 1 for yes)
n The time this host was scanned (in time() format) (optional)
By looking at the satan-1.1.1/results/satan-data/all-hosts file, the structure of these records can
be seen:
m2.notreal.com|12.34.56.78|0|2|0|817008639
mailhub.notreal.com|12.3.45.67|1|-1|0|
Notice that mailhub.notreal.com has not been scanned (-1) and therefore has no time entry.
Examining All the Things It Did
The SATAN todo file contains a list of hosts, and probes that have been run against those
hosts. Each todo record consists of three fields, separated by a pipe (|) character. The fields are
as follows:
n The hostname
n The name of the tool that was run against that host
n Any arguments used by that tool during the run against that host
The best way to understand this database format is to look at the satan-1.1.1/results/satandata/
todo file:
m2.notreal.com|tcpscan.satan|0,80,ftp,telnet,smtp,nntp,uucp,6000|
m2.notreal.com|dns.satan|
m2.notreal.com|rpc.satan|
m2.notreal.com|xhost.satan|-d m2.notreal.com:0
Notice that the system m2.notreal.com had tcpscan.satan scan the system for the listed TCP
ports, then a dns scan, an rpc scan, and finally, an xhost test.
Understanding the SATAN Rulesets
When making a scan, SATAN first examines vulnerabilities that are explicitly listed in the scan
level of the satan.cf file. The scan level can indicate optional checks for a vulnerability by
530 Part II: Gaining Access and Securing the Gateway
listing it with a ?. This means that SATAN will check the rulesets to see whether this specific
vulnerability scan should be done, based on information that has already been gathered.
For example, the light scan includes showmount.satan? after the rpc.satan entry. This means
that the showmount.satan script is run only if the mount service is available on the target
system, and this information is available as a result of the rpc.satan output. This conditional
execution can speed up the execution of SATAN by avoiding unnecessary tests.
Six files in the rules directory constitute the rulesets for SATAN: drop, facts, hosttype, services,
todo, and trust.
drop
The drop file is used to determine which facts should be ignored. It currently ships with only a
single rule: ignore NFS-exported /cdrom directories. Note that cdrom directories that are
NFS-exported but are not named /cdrom are not dropped from the facts database.
The entries in this file use PERL condition matching against each a SATAN fact. The single
rule included in the drop file is
$text =˜ /exports \/cdrom/i
This rule says that the record should be dropped if the $text field contains exports /cdrom,
because that is the field between the //. Note that the i at the end indicates that the search
should be case-insensitive.
facts
The facts file deduces new facts based on existing data. Each entry consists of a condition,
which is another PERL search condition that is applied against SATAN facts and a fact that is
added to the facts file if that condition evaluates to true.
An example clarifies this structure:
/runs rexd/ $target|assert|a|us|ANY@$target|ANY@ANY|REXD access|rexd is
åvulnerable
This entry indicates that if a SATAN record includes the text runs rexd, a new SATAN fact is
added (assert) to the facts file: this fact says that the $target that has a runs rexd entry (as a
result of the rpc.satan scan) is vulnerable.
The remaining entries in the default SATAN facts file look for old sendmail versions,
old ftpd versions, and the existence of a modem on a TCP port.
A recent problem with telnetd programs from various manufacturers permitted remote users to
pass environment variables, such as shared library information, to the telnetd. If this problem
could be detected by the banner given by a vendor’s telnetd, this vulnerability could be
detected by adding an entry into this facts file. Unfortunately, most vendors do not put version
SATAN and the Internet Inferno 531
information into the telnetd banner, but as an example imagine that vendor XYZ include an
RCS string of 1.2.3.4. Then, an entry such as this might be reasonable:
/XYZ m2 V5R4 1.2.3.4/
$target|assert|a|uw|ANY@$target|ANY@ANY|Telnetd access|telnetd is vulnerable
This is making further assumptions about the problem that may or may not be accurate; the
example is just for illustration of the process.
hosttype
The hosttype file provides rules that allow SATAN to recognize host types based on the banners
returned from telnetd, ftpd, and sendmail.
The file consists of a major section (CLASS class_name) that is just used for reporting,
followed by the real rules. Each rule is another PERL condition, which is used to try to match
against fact records, and the hosttype, which is the conclusion that results if the PERL condition
evaluates to true.
Looking at the Ultrix CLASS of the satan-1.1.1/rules/hosttype, three rules are used to identify
various versions of Ultrix:
CLASS Ultrix
/ultrix[\/v ]+([.0-9]+[A-Z]*)/i “Ultrix $1”
/ultrix version 4/i && length(HOSTTYPE) <= 6 “Ultrix 4”
UNKNOWN && /ultrix/i “Ultrix”
Notice that version information can be extracted from the match using the standard PERL
matching parameters. In the first case, the $1 corresponds to the information that matches to
those parts inside the ().
services
The services file classifies hosts by services, to make reports more suitable for reading. The file is
broken into two parts: SERVERS and CLIENTS. Each rule consists of a PERL matching
condition that has access to the facts database and can reference each part of a fact using the
variable names such as $service or $text. If that rule evaluates to true, the second field is
assumed to be provided (if under SERVER) or used (if under CLIENT). A third field can
specify a hostname; if not specified, SATAN assumes that the $target of the current fact record
is the hostname.
Here is an example from the satan-1.1.1/rules/services file:
/offers gopher/ Gopher
/offers http/ WWW
Notice that this services file is used by SATAN when generating a Results screen or a report.
The output from the conclusions drawn by these rules is not stored in any file.
532 Part II: Gaining Access and Securing the Gateway
todo
The todo file specifies probes to try based on existing facts. Each rule consists of a condition,
once again a PERL matching statement, a target to probe, the tool to use in the probe, and any
arguments needed for that tool.
Here is an example from the satan-1.1.1/rules/todo file:
$service eq “ypserv” $target “ypbind.satan”
$service eq “rexd” $target “rex.satan”
The rules indicate that if the $service field of a record in the SATAN facts database is either
“ypserv” or “rexd”, SATAN should run either “ypbind.satan” or “rex.satan” against the $target
indicated in that record.
This file can be used for expansion of SATAN. If, for example, a user would find a vulnerability
against the echo service, the user could create an echo.satan tool and add an entry such as
this:
$service eq “echo” $target “echo.satan”
trust
The trust file contains rules that are used by SATAN to classify hosts on the basis of trust. The
first field is a PERL matching condition that is applied against each fact record, whereas the
second field is the conclusion drawn if the first field evaluates to true.
Here is an example from the satan-1.1.1/rules/trust file:
$text =˜ / mounts \S+/ NFS export
/serves nis domain/ NIS client
The first entry indicates that if the $text field of a fact contains the word mounts followed by a
string, this system is exporting NFS file systems. The second entry indicates that if the fact
contains the text serves nis domain, this system trusts NIS clients.
Extending SATAN
A new probe can be added to SATAN by creating a new .satan tool and putting it into the bin/
directory. Then the tool name must be explicitly added to the satan.cf file under a scan level.
The tool can be conditionally invoked using the rulesets, if so desired, as discussed previously,
by added it to the satan.cf using a trailing ?. Finally, ruleset changes can be added, if so desired,
and new documentation describing the vulnerability and how to deal with it is a worthwhile
addition.
You might extend SATAN to search for the FTP server bounce problem described earlier in
this chapter. The goal of ftpbounce.satan is to see if the remote ftpd server permits a client to
SATAN and the Internet Inferno 533
specify any remote client IP address and TCP port to receive a file transfer. If the remote ftpd
permits a PORT command with an IP address that is different from the originating source,
and a TCP port that is reserved, the ftpd is open to this problem.
The quickest way to make ftpbounce.satan is to copy ftp.satan to ftpbounce.satan and make
appropriate modifications. (Each .satan tool must output fact records, and using the existing
approach from current .satan tools makes this quite easy.) Here is a clip from ftp.satan:
open(FTP, “$FTP -nv <<EOF
open $target
quote user anonymous
quote pass -satan\@
cd /
put /etc/group $$.foo
dele $$.foo
quit
EOF |”) || die “cannot run $FTP”;
while(<FTP>) {
if (defined($opt_v)) {
print;
}
if (/^230/) {
This just needs to be modified to look for a 200 reply to an attempt to send a PORT command,
as shown in this clip:
open(FTP, “$FTP -nv <<EOF
open $target
quote user ftp
quote pass -satan\@
quote port 1,2,3,4,0,25
quit
EOF |”) || die “cannot run $FTP”;
while(<FTP>) {
if (defined($opt_v)) {
print;
}
if (/^200 PORT command successful/) {
$status = “a”;
$severity = “x”;
$trustee = “”;
$trusted = “”;
$service_output = “BOUNCE”;
$text = “offers ftp server bounce”;
Now the ftpbounce.satan script is ready to be listed in the heavy scan listing in satan.cf. At this
point, an HTML document describing the fix (“Get the patch from a vendor, or the latest
wu-ftpd”) should be added into the links available on the tutorials Web page. Lastly, the
ftpbounce.satan tool and the new Web pages should be sent to the creators of SATAN for
inclusion into new versions of the program. (Send the changes to satan@fish.com.)
534 Part II: Gaining Access and Securing the Gateway
The tool does not have to be written in PERL. It can be written in any language as long it
takes an argument specifying the target name and emits records that comply to the facts
database format. It is possible to use hybrid tools, and SATAN does this: many of the .satan
tools are written in PERL but call compiled programs, such as nfs-chk (which is written in C).
Long-Term Benefits of Using SATAN
SATAN can be a worthwhile tool for security administrators in managing the security of a
network of systems that are maintained by a distributed group of owners. SATAN can be used
to assist security administrators in enforcing company policies, such as preventing unrestricted
NFS exports or X server access. The reality of most organizations involves the fact that it is
difficult to enforce such software policies without regular auditing. SATAN can be used to do
such auditing remotely. SATAN also provides a convenient framework for the addition of new
network vulnerability scans.
Works Cited
Alighieri, Dante. Inferno. Norton Anthology of World Masterpieces, Volume 1, 4th Edition.
W.W. Norton & Company, New York, 1979.
Belgers, Walter. “Unix Password Security,” available from ftp://ftp.win.tue.nl/pub/
security/UNIX-password-security.txt.Z; INTERNET.
Bellovin, Steven M. “Security Problems in the TCP/IP Protocol Suite,” 1993, available from
ftp://ftp.research.att.com/dist/internet_security/ipext.ps.Z; INTERNET.
Farmer, Dan and Wietse Venema. “Improving the Security of Your Site by Breaking Into It,”
1993, available from ftp://ftp.win.tue.nl/pub/security/admin-guide-tocracking.
101.Z; INTERNET.
Fisher, John. “CIAC Bulletin G-4: X Authentication Vulnerability,” 1995, available from
http://ciac.llnl.gov; INTERNET.
Carl Landwehr et al., “A Taxonomy of Computer Program Security Flaws, with Examples,”
Naval Research Laboratory, NRL/FR/5542—93-9591, 1993.
Leopold, George. “Infowar: Can bits really replace bullets?” EE Times, Nov 6, 1995.
Schuba, Christopher and Eugene Spafford. “Addressing Weaknesses in the Domain Name
System Protocol,” 1993, available from ftp://coast.cs.purdue.edu/pub; INTERNET.
U.S. Department of Defense, Trusted Computer System Evaluation Criteria, 1985a, available
from ftp://ftp.cert.org/pub/info/orange-book.Z; INTERNET.
Kerberos 535
Kerberos
C H AP T E R C H AP T E R C H A P T E R C H A PT ER C H A PTE R CHA P TER CHAPT E R C H A P T E R
A
9
conventional time-sharing system requires a prospective
user to provide an identity, and to authenticate that
identity before using its services. A network that
connects prospective clients with services has a corresponding
need to identify and authenticate its clients.
One approach is for the service to trust the authentication
performed by the client system. The Unix network
applications lpr and rcp, for example, trust the user’s
workstation to reliably authenticate its clients.
Unfortunately, a workstation is under the complete
control of its user. The user can replace the operating
system, or even replace the machine itself. A secure
network service cannot rely on the integrity of the
workstation to perform a reliable authentication.
536 Part II: Gaining Access and Securing the Gateway
Kerberos is a network authentication system developed at MIT to address this problem. It
enables users communicating over networks to prove their identity to each other while
optionally preventing eavesdropping or replay attacks. It provides data secrecy using encryption.
Kerberos provides real-time authentication in an insecure distributed environment.
Note Kerberos is a North American technology; because of export restrictions it is not
available outside of North America. To solve the same problems and to provide
European companies with a compatible product, another project has been started in
Europe. Their product is called SESAME, and is fully compatible with Kerberos
Version 5.
How Kerberos Works
The Kerberos model is based on a trusted third-party authentication protocol. The original
design and implementation of Kerberos was the work of MIT Project Athena staff members.
Kerberos is publicly available and has seen wide use.
Kerberos works by providing users or services with “tickets” that they can use to identify
themselves, and secret, cryptographic keys for secure communication with network resources.
A ticket, which is a sequence of a few hundred bytes, can be embedded in virtually any
network protocol. This enables the processes implementing that protocol to be sure about the
identity of the principals involved. Although most implementations of Kerberos use TCP/IP,
some implementations use other protocols.
Practically speaking, Kerberos usually is used in application-level protocols, such as Telnet or
FTP, to provide user-to-host security. Data stream mechanisms, such as SOCK_STREAM or
RPC, can also use it as the implicit authentication system. At a lower level, Kerberos also can
be used for host-to-host security in protocols such as IP, UDP, or TCP—although such
implementations are rare.
Kerberos is only a part of a security implementation. A full security implementation requires
authentication, assurance, security policy, and documentation. Kerberos provides services in
the first two areas:
n It provides mutual authentication and secure communication between principals on an
open network.
n It manufactures secret keys for any requester and provides a mechanism for these secret
keys to be safely propagated through the network.
Using Kerberos on time-sharing machines greatly weakens its protections. A user’s tickets are
only as secure as the “root” account. Dumb terminals and most X terminals do not understand
the Kerberos protocol. Using Kerberos to authenticate to the local workstation is easily
circumvented.
Kerberos 537
In a Kerberos system, a designated site on the network, called the Kerberos authentication server,
performs centralized key management and administrative functions. The server maintains a
database that contains all users’ secret keys. It generates session keys whenever two users want
to communicate securely and authenticates the identity of a user who requests secured network
services.
Like other secret-key systems, Kerberos requires trust in a third party—the Kerberos authentication
server in this case. If the server is compromised, the integrity of the whole system fails.
The Kerberos Network
Kerberos divides the network into security domains, called realms. Each realm has its own
authentication server, and implements its own security policy. This allows organizations
implementing Kerberos to have different levels of security for different information classes
within the organization. A realm can accept authentications from other realms or not accept
them without a re-authentication if the information security policy requires re-authentication.
Realms are hierarchical. That is, each realm may have child realms, and each realm may have
a parent. This structure allows realms that have no direct contact to share authentication
information. If an organization has a corporate-wide user naming policy, for example, it is
possible for a user authenticating in one Kerberos realm to connect to a computer in another
realm without requiring re-authentication. This is true even if logically there is no direct
connection between the two realms. Specifically, if an organization ABC.COM has installed
Kerberos, it may have created departmental realms PAYROLL and RESEARCH (see fig. 9.1).
If a user authenticates to the realm RESEARCH.ABC.COM and wants to use information
from PAYROLL.ABC.COM, there is no need to re-authenticate. The user identity is passed
between the realms by way of the parent realm ABC.COM. Because both realms are part of
the same organization, they can trust each other.
Internet
ABC.COM
Production Research Accounting Payroll Operations
DEF.COM
Figure 9.1
Kerberos realm hierarchy.
538 Part II: Gaining Access and Securing the Gateway
On the other hand, if a user authenticates to DEF.COM and wants to use information from
RESEARCH.ABC.COM, Kerberos can require the user to re-authenticate to an authentication
server within ABC.COM before sharing information. Because Kerberos provides secure
authentication and encryption, this communication can take place securely over the Internet, a
public, hostile network. If the two companies want to accept each other’s authentication, the
two root Kerberos servers ABC.COM and DEF.COM need to share an encryption key.
Because the Kerberos naming convention supports Internet domain names, a Kerberos user at
DEF.COM can authenticate as a user to ABC.COM even if the two Kerberoses cannot
directly share authentications.
RFCs
An RFC is a request for comment. This is a mechanism used to distribute ideas for standards
in the internetworking industry. The RFC describes the protocol or standard the issuer would
like to see adopted. Earlier versions of Kerberos were not described in RFCs. RFC 1510,
however, describes version 5 of Kerberos.
RFC 1510
This document gives an overview and specification of version 5 of the protocol for the
Kerberos network authentication system. It is available from the following:
ftp://ftp.isi.edu/in-notes/rfc1510.txt
Much of the information in this chapter is based on RFC 1510, and some portions are directly
extracted from the RFC.
Goals of Kerberos
The design of Kerberos has goals in three areas: authentication, authorization, and accounting.
In addition, any function that benefits from the secure distribution of encryption keys will
benefit.
There is much discussion in the security industry of how particular systems fit into the
government-trusted host classification system. Kerberos by itself does not fit into the trust
classifications because it does not offer a full security environment. It can, however, be used as
a component when building a secure network. Kerberos provides an authentication mechanism
and encryption tools that can be used to implement a secure networking environment.
Authentication
Any user can make a claim to an ID. The authentication process tests this claim. During basic
authentication, the user is asked to provide a password. During enhanced authentication, the
user is asked to use a piece of hardware (a token) assigned to the legitimate owner of that ID.
Kerberos 539
Alternatively, the user can be asked to provide biometric measurements (thumbprints, voiceprints,
or retinal scans) to authenticate the claim to that ID.
Kerberos’ goal is to remove authentication from the insecure workstation to a centralized
authentication server. This authentication server can be physically secured, and can be controlled
to ensure its reliability. This ensures that all users within a Kerberos realm have been
authenticated to the same standard or policy.
Authorization
After a user has been authenticated, the application or network service can administrate
authorization. It looks at the requested resource or application function and verifies that the
owner of the ID has permission to use the resource or perform the application function.
Kerberos’ goal is to provide a trusted authentication of the ID on which a system can base its
authorizations.
Accounting
The goal of accounting is to support quotas charged against the client (to limit consumption)
and/or charges based on consumption. In addition, accounting audits users’ activities to ensure
that responsibility for an action can be traced to the initiator of the action. Auditing, for
example, can trace the originator of an invoice back to the individual who entered it into the
system.
Security of the accounting and auditing system is important. If an intruder is able to modify
accounting and auditing information, it is no longer possible to ensure that a user is responsible
for his/her actions.
The goal of Kerberos is to permit attachment of an integrated, secure, reliable accounting
system.
How Authentication Works
Kerberos performs authentication as a trusted third-party authentication service using shared
secret key cryptography.
The authentication process proceeds as follows:
1. A client sends a request to the authentication server, requesting “credentials” for a given
application server (see fig. 9.2 [Message 1]).
These credentials can be directly for an application server or for a Ticket Granting Server.
540 Part II: Gaining Access and Securing the Gateway
2. The authentication server responds with these credentials, encrypted in the client’s key
(see fig. 9.2 [Message 2]).
The credentials consist of the following:
n A “ticket” for the server.
n A temporary encryption key (called a session key).
3. If the ticket is for a Ticket Granting Server, the client then requests a ticket for the
application server from the Ticket Granting Server (see fig. 9.2 [Message 3]).
4. The Ticket Granting Server replies with a ticket for the application server (see fig. 9.2
[Message 4]).
5. The client transmits the ticket (which contains the client’s identity and a copy of the
session key, all encrypted in the server’s key) to the application server (see fig. 9.2
[Message 5]).
6. The session key, now shared by the client and application server, is used to authenticate
the client, and can be used to authenticate the server (see fig. 9.2 [Message 6]).
It also can be used to encrypt further communication between the two parties or to
exchange a separate subsession key to encrypt further communication.
Figure 9.2
Kerberos authentication
protocol.
An implementation consists of one or more authentication servers running on physically secure
hosts. Each authentication server maintains a database of principals (that is, users and servers)
and their secret keys. Code libraries on the server provide encryption and implement the
Kerberos protocol. Before a typical network can add authentication to its transactions, it adds
Kerberos
authentication
server
Kerberos
ticket granting
server
Kerberos
application
server
Kerberos
client
1 2 3
4
5
6
Kerberos 541
calls to the Kerberos library, which results in the transmission of the necessary messages to
achieve authentication.
A client can use two methods for asking a Kerberos server for credentials.
n Client sends a cleartext request for a ticket for the desired function server to the function
server. The reply is sent encrypted in the client’s secret key. Usually, this request is for a
Ticket Granting Ticket that can be used later with the Ticket Granting Server.
n Client sends a request to the Ticket Granting Server in the same manner as when
contacting any other application server that requires Kerberos credentials. The reply is
encrypted in the session key from the Ticket Granting Ticket.
After credentials are obtained, they can be used to establish the level of security the application
requests:
n Verify the identity of the principals in a transaction
n Ensure the integrity of messages exchanged between them
n Preserve privacy of the messages
The application can choose whatever level of protection it deems necessary. The level of
security chosen for a particular transaction depends upon the security policy being implemented
by the application.
To verify the identities of the principals in a transaction, the client transmits the ticket to the
function server. The ticket is sent in cleartext (cleartext is readable by anyone who chooses to
look at the message). Parts of it are encrypted, but this encryption doesn’t thwart replay. An
attacker could intercept it and reuse it. So, additional information accompanies the message to
prove it originated at the principal to whom the ticket was issued. This information, called an
authenticator, is encrypted in the session key, and includes a timestamp. The timestamp proves
that the message was generated recently and is not a replay. Encrypting the authenticator in the
session key proves that a party possessing the session key generated it. Because no one except
the requesting principal and the server know the session key (it never travels over the network
in the clear), this guarantees the identity of the client.
The integrity of the messages exchanged between principals can be guaranteed using the
session key. This approach provides detection both of replay attacks and message stream
modification attacks, by generating and transmitting a collision-proof checksum called a hash
or digest of the client’s message, keyed with the session key. Checksums are discussed later in
this chapter.
Privacy and integrity of the messages exchanged between principals can be secured by using the
session key passed in the ticket and contained in the credentials to encrypt the data to be
passed.
542 Part II: Gaining Access and Securing the Gateway
Authentication exchanges require read-only access to the Kerberos database. Sometimes
the entries in the database must be modified, however, such as when adding new principals
or changing a principal’s key. Modification of entries is done using a protocol between a
client and a third Kerberos server, the Kerberos Administration Server. The administration
protocol is not described here. Another protocol concerns maintaining multiple copies of
the Kerberos database, but it’s an implementation detail and can vary to support different
database technologies.
What Kerberos Doesn’t Do
Kerberos doesn’t solve denial of service attacks. These protocols have places in which an
intruder can prevent an application from participating in the proper authentication steps.
Detection and solution of such attacks, some of which can appear to be common failure modes
for the system, usually is best left to the human administrators and users.
Principals must keep their secret keys secret. If an intruder somehow steals a principal’s key,
the villain can masquerade as that principal or impersonate any server to the legitimate
principal.
Kerberos doesn’t solve password-guessing attacks. If a user chooses a poor password, an
attacker can successfully mount an off-line dictionary attack. The attacker attempts to decrypt
repeatedly, employing successive entries from a dictionary, messages encrypted under a key
derived from the user’s password.
Kerberos is also vulnerable to clock synchronization attacks. Each host on the network must
have a clock “loosely synchronized” to the time of the other hosts. This synchronization serves
to reduce the bookkeeping needs of application servers when they perform replay detection.
The degree of “looseness” can be configured per server. If the clocks are synchronized over the
network, the clock synchronization protocol must itself be secured from network attackers.
Principal identifiers should not be recycled. A typical mode of access control uses Access
Control Lists to grant permissions to particular principals. An Access Control List is attached
to any object that requires restricted access. The list should consist only of principal identifiers,
although group identifiers are ususally allowed. When a user wants to make use of the object,
the operating system checks the Access Control List. If the user is listed as an authorized
principal, access is granted. If a stale list entry remains for a deleted principal and the principal
identifier is reused, the new principal inherits rights specified in the stale entry. Not reusing
principal identifiers erases the danger of inadvertent access. Kerberos does not at this time
coordinate or manage Access Control Lists. This entire problem is refered to as object reuse.
Any system that wants to be governemt security certified must control object reuse and prevent
it from occurring.
Kerberos 543
Encryption
Kerberos uses encryption to protect information passing over the network. Encryption is the
transformation of data into a form no one can read without the key, for the purpose of
ensuring privacy by keeping the information hidden from anyone for whom it is not intended,
even if they can see the encrypted data.
An encryption system is a set of rules or operations to be applied to the message. The rules
require a randomizing seed or starting point, called a key. The original message is called
plaintext. The disguised message is called ciphertext.
Note Encryption is a procedure to convert plaintext into ciphertext, and decryption is a
procedure to convert ciphertext into plaintext.
Encryption systems can be patented. Many encryption systems have been patented, including
DES and RSA. The basic ideas of public-key encryption are contained in U.S. Patent
4,200,770, by M. Hellman, W. Diffie, and R. Merkle, issued 4/29/80 and in U.S. Patent
4,218,582, by M. Hellman and R. Merkle, issued 8/19/80. Similar patents have been issued
throughout the world. Public Key Partners, of Sunnyvale, California holds exclusive licensing
rights to both patents, as well as the rights to the RSA patent.
The encryption systems in use in Kerberos and most publicly available encryption systems
(such as PGP) are patented. Any commercial implementation of Kerberos will be subject to the
license granted for the encryption system.
NSA or other intelligence or defense agencies have intervened to block some patent applications
for encryption systems, under the authority of the Invention Secrecy Act of 1940 and the
National Security Act of 1947.
The NSA is the U.S. government’s official communications security body. The NSA has a
mandate to listen to and decode all foreign communications of interest to the security of the
United States. The NSA is the largest employer of mathematicians and the largest purchaser of
computer hardware in the world. The NSA probably possesses encryption expertise many years
ahead of the public state of the art, and undoubtedly can break many of the systems used in
practice. For reasons of national security, almost all information about the NSA is classified. It
also has used its power to slow the spread of publicly available encryption, to prevent national
enemies from employing methods too strong for the NSA to break.
As the premier cryptographic government agency, the NSA has enormous financial and
computer resources. Developments in encryption achieved at the NSA are not made public.
This secrecy has led to many rumors about the NSA’s capability to break popular cryptosystems
like DES and that the NSA secretly has placed weaknesses, called trapdoors, in DES.
These rumors have never been proved or disproved, and the criteria the NSA uses to select
encryption standards never have been made public.
544 Part II: Gaining Access and Securing the Gateway
The NSA exerts influence over commercial cryptography in several ways. First, it controls the
export of cryptography from the U.S. The NSA generally does not approve export of products
used for encryption unless the key size is strictly limited. It does, however, approve for export
any products used for authentication only, no matter how large the key size, as long as the
product cannot be converted to be used for encryption. The NSA also has blocked encryption
methods from being published or patented, citing a national security threat. Additionally, the
NSA serves an advisory role to NIST (National Institute of Standards and Technology, a
division of the U.S. Department of Commerce) in the evaluation and selection of official U.S.
government computer security standards. In this capacity, it has played a prominent role in the
selection of DES. The NSA also can exert market pressure on U.S. companies to produce (or
refrain from producing) encryption products, because the NSA itself often is a major customer
for these same companies.
The governments of Canada and the United States have synchronized their policies on export
of encryption. As a result, any distribution of encryption that is legal within the U.S. is also
legal into Canada. Canadians wanting to export encryption to a third country must go through
the same applications for an export license with the Canadian government.
Private, Public, Secret, or Shared Key Encryption
There is a wide range of terminology in use for only two concepts. Here are the concepts:
n Secret. An algorithm that depends on a key that must remain private is a secret key
system. Kerberos uses DES, which is a secret key system, to encrypt information. Because
Kerberos shares the secret key among a small group of principals, it is often referred to as
a shared secret key system.
n Public. An algorithm that permits a key to be published is called a public key system.
PGP uses RSA, which is a public key encryption system.
If a system depends on a secret key, the intention clearly is to prevent usage by anyone who
lacks the key. Any message encrypted with a secret key may only be decrypted by the holder of
the secret key.
A public key system is actually a dual key system. Each key consists of two parts, a secret part
held by a single individual, and a public part that may be published to the world. Anyone with
the public key may encrypt a message to the holder of the private key, and be confident that
only one individual has access to the message. In the other direction, the holder of the private
part may encrypt a message and send it to the world. Anyone who decrypts the message with
the public part of the key can be confident that the message could only have originated from
one individual. By combining the two systems and double encrypting a message, it is possible
to send a message to a single individual and provide the recipient with confidence that the
message could only have originated from one person.
Kerberos 545
The primary advantage of public-key cryptography is increased security. The private keys do
not need to be transmitted or revealed to anyone. In a secret-key system, by contrast, the
potential always exists for an enemy to discover the secret key during transmission.
A disadvantage of using public-key cryptography for encryption is speed. Certain popular
secret-key encryption methods are significantly faster than any currently available public-key
encryption methods.
With recent advances in the speed of computer hardware, the trade-off between speed and
security is leaning toward the public key-based systems. Although Kerberos can be implemented
with a public key encryption system, the option to encrypt all data between principals
leaves the potential for very large amounts of encryption to take place. It is only when you plan
to encrypt large volumes of data that a shared secret key system starts to become the better
choice. With this in mind, Kerberos has been designed to handle the problem of secure
distribution of secret keys.
Private or Secret Key Encryption
A secret-key encryption system consists of an encryption function and a decryption function.
The encryption function uses the key to generate a mapping of the plaintext into the
ciphertext. In the reverse, the decryption system takes the same key to generate a mapping of
the ciphertext back into the plaintext. Such systems, in which the same key value is used to
encrypt and decrypt, also are known as symmetric cryptosystems.
Although many secret key encryption systems are around, the most well-known system is DES.
DES and Its Variations
Originally developed by IBM, DES stands for Data Encryption Standard, an encryption block
cipher. The U.S. government defined and endorsed it in 1977 as an official standard. The
details can be found in the official FIPS (Federal Information Processing Standards) publication.
DES has been studied extensively over the past 18 years and is the most well-known and
widely used encryption system in the world.
DES is a secret-key, symmetric cryptosystem. When DES is used for communication, the
sender and receiver both must know the same secret key, because it’s used to encrypt and
decrypt the message. DES was designed to be implemented in hardware operates relatively fast
(compared to other encryption systems) on 64-bit blocks with a 56-bit key. It works well for
bulk encryption, that is, for encrypting a large set of data.
DES has been recertified as an official U.S. government encryption standard every five years.
The government last recertified DES in 1993, but has indicated that it might not recertify it
again.
546 Part II: Gaining Access and Securing the Gateway
As far as is known, DES never has been broken with a practical attack, despite the efforts of
many researchers over many years. The obvious method of attack is a brute-force exhaustive
search of the key space. This takes 255 steps on average. Early on, someone suggested that a
rich and powerful enemy could build a special-purpose computer capable of breaking DES by
exhaustive search in a reasonable amount of time. Wiener estimated the cost of a specialized
computer to perform such an exhaustive search at one million dollars—a sum within the
budget of a moderate-sized corporation, or a special interest group. Martin Hellman later
showed a time-memory trade-off that provides improvement over exhaustive search if memory
space is plentiful, after an exhaustive precomputation. These ideas have fostered doubts about
the security of DES. Accusations also flew that the NSA had intentionally weakened DES.
The consensus is that DES, used properly, is secure against all but the most powerful enemies.
Triple encryption DES might be secure against anyone at all. Biham and Shamir have stated
that they consider DES secure.
When using DES, several practical considerations can affect the security of the encrypted data.
One should change DES keys frequently, to prevent attacks that require sustained data
analysis. In a communications context, the sender or receiver must find a secure way to
communicate the DES key to the other.
DES can be used for encryption in several officially defined modes. The U.S. Department of
Commerce Federal Information Processing Standard 81, published in 1980, defines the four
standard modes of operation (and numerous nonstandard ones, as well). Some are more secure
than others. The four standard modes are as follows:
n ECB (Electronic Codebook). Encrypts each 64-bit block of plaintext consecutively
under the same 56-bit DES key. This is the least secure method of implementing DES.
n CBC (Cipher Block Chaining). Each 64-bit plaintext block is XORed with the
previous ciphertext block before being encrypted with the DES key. Thus, the encryption
of each block depends on previous blocks and the same 64-bit plaintext block
encrypts to different ciphertext, depending on its context in the overall message. CBC
mode helps protect against certain attacks, although not against exhaustive search or
differential cryptanalysis.
n CFB (Cipher Feedback). Allows DES with block lengths less than 64 bits. It uses the
previously generated cyphertext as input to DES to create a randomizer to combine with
the next block of plaintext. In practice, CBC is the most widely used mode of DES,
specified in several standards, including Kerberos.
n OFB (Output Feedback Mode). Is the same as CFB except it does not re-encrypt the
cypherblock before using it as a randomizer. OFB is not as secure as CFB.
FIPS 46-1 (the federal standard defining DES) says, “The algorithm specified in this standard
is to be implemented using hardware (not software) technology. Software implementations in
Kerberos 547
general purpose computers are not in compliance with this standard.” Despite this, software
implementations abound, and are used by government agencies.
Encryption Export Issues
All cryptographic products need export licenses from the State Department, acting under
authority of the International Traffic in Arms Regulation (ITAR). ITAR defines cryptographic
devices, including software, as munitions. The U.S. government has historically been reluctant
to grant export licenses for encryption products it sees as stronger than a certain non-publicly
assigned level. Under current regulations, a vendor seeking to export a product using cryptography
first submits a request to the State Department’s Defense Trade Control office. Export
jurisdiction then can be passed to the Department of Commerce, whose export procedures
generally are simple and efficient. If jurisdiction remains with the State Department, then
further (perhaps lengthy) review must occur before export can be approved or denied. The
NSA sometimes becomes directly involved at this point. The details of the export approval
process change frequently.
The NSA has de facto control over export of cryptographic products. The State Department
does not grant licenses without NSA approval and routinely grants them whenever NSA does
approve. Therefore, policy decisions concerning exporting cryptography ultimately rest with
the NSA.
The NSA’s stated policy is not to restrict export of cryptography for authentication. Its
concern lies only with the use of cryptography for privacy. A vendor seeking to export a
product for authentication is granted an export license only so long as it can demonstrate that
the product cannot be easily modified for encryption. This is true even for very strong systems,
such as RSA with large key sizes. Furthermore, the bureaucratic procedures are simpler for
authentication products than for privacy products. An authentication product needs NSA and
State Department approval only once, whereas an encryption product could need approval for
every sale or every product revision.
The U.S. State Department and the NSA strictly regulates export of DES, in hardware or
software. The government rarely approves export of DES, although DES is widely available
overseas. Software developers in many countries have produced DES products from the
published specifications. These products are functionally compatible with U.S. products.
Financial institutions and foreign subsidiaries of U.S. companies are exceptions.
Export policy currently is a matter of great controversy. Many software and hardware vendors
consider current export regulations overly restrictive and burdensome. The Software Publishers
Association (SPA), a software industry group, has recently been negotiating with the government
to get export license restrictions eased. One agreement was reached that allows simplified
procedures for export of two bulk encryption ciphers, RC2 and RC4, when the key size is
limited. Also, export policy is less restrictive for foreign subsidiaries and overseas offices of U.S.
companies.
548 Part II: Gaining Access and Securing the Gateway
In March 1992, the Computer Security and Privacy Advisory Board voted unanimously to
recommend a national review of cryptography policy, including export policy. The Board is an
official advisory board whose members are drawn from the government and the private sector.
The Board stated that a public debate is the only way to reach a consensus policy to best satisfy
competing interests. National security and law enforcement agencies like restrictions on
cryptography, especially for export, whereas other government agencies and private industry
want greater freedom for using and exporting cryptography. Export policy has traditionally
been decided solely by agencies concerned with national security, without much input from
those who want to encourage commerce in cryptography. U.S. export policy could undergo
significant changes in the next few years.
Note The legal status of encryption in many countries has been placed on the World
Wide Web. You can access it using the following URL:
http://web.cnam.fr/Network/Crypto/
In much of the civilized world, encryption is legal or at least tolerated. In some countries,
however, such activities can land you before a firing squad! Check with the laws in your
country before you use any encryption product. Some countries in which encryption is illegal
are Russia, France, Iran, and Iraq.
Encryption and Checksum Specifications
The Kerberos protocols described in the RFC are designed to use stream encryption ciphers,
such as the Data Encryption Standard (DES), in conjunction with block chaining and
checksum methods. Encryption is used to prove the identities of the network entities participating
in message exchanges. The Key Distribution Center for each realm is trusted by all
principals registered in that realm to store a secret key in confidence. Proof of knowledge of
this secret key is used to verify the authenticity of a principal.
The Key Distribution Center uses the principal’s secret key (in the Authentication Server
exchange) or a shared session key (in the Ticket Granting Server exchange) to encrypt responses
to ticket requests. The capability to obtain the secret key or session key implies
knowing the appropriate keys and the identity of the Key Distribution Center. The capability
of a principal to decrypt the Key Distribution Center response and present a ticket and a
properly formed authenticator (generated with the session key from the Key Distribution
Center response) to a service verifies the identity of the principal. Likewise, the capability of
the service to extract the session key from the ticket and prove its knowledge thereof in a
response verifies the identity of the service.
The Kerberos protocols generally assume that the encryption used is secure from cryptanalysis.
Sometimes, though, the order of fields in the encrypted portions of messages is arranged to
Kerberos 549
minimize the effects of poorly chosen keys. Choosing good keys still is important. If keys are
derived from user-typed passwords, those passwords need to be chosen well to make brute
force attacks more difficult. Poorly chosen keys still make easy targets for intruders.
The following sections specify the encryption and checksum mechanisms currently defined
for Kerberos and describe the encoding, chaining, and padding requirements for each. For
encryption methods, placing random information (often referred to as a confounder) at the start
of the message is often a good idea. The requirements for a confounder are specified along with
each encryption mechanism.
Some encryption systems use a block-chaining method to improve the security characteristics
of the ciphertext. These chaining methods often don’t provide an integrity check upon
decryption. Such systems (such as DES in Cipher Block Chaining mode) must be augmented
using a checksum of the plaintext that can be verified at decryption and used to detect any
tampering or damage. Such checksums should be good at detecting burst errors in the input. If
any damage is detected, the decryption routine is expected to return an error indicating the
failure of an integrity check. Each encryption type is expected to provide and verify an
appropriate checksum. The specification of each encryption method sets out its checksum
requirements.
Finally, if a key is to be derived from a user’s password, an algorithm for converting the
password to a key of the appropriate type is required. The string-to-key function ideally should
be one-way and mapping should be different in different realms, because users registered in
more than one realm often use the same password in each. An attacker compromising the
Kerberos server in one realm should not be able to just obtain or derive the user’s key in
another realm.
Encryption Specifications
The following structure describes all encrypted messages. The encrypted field that appears in
the unencrypted part of messages is a sequence that consists of an encryption type, an optional
key version number, and the ciphertext.
EncryptedData = {
etype[0] INTEGER -- Encryption Type
kvno[1] INTEGER OPTIONAL,
cipher[2] BYTE STRING -- ciphertext
}
n etype. Identifies the encryption algorithm used to encrypt the cipher.
n kvno. Contains the version number of the key under which data is encrypted. Present
in messages encrypted under long-lasting keys, such as principals’ secret keys. Used to
determine which key to use when a ticket is valid across a change in key, such as when a
user changes his password.
n cipher. Contains the encrypted field(s).
550 Part II: Gaining Access and Securing the Gateway
The cipher field is generated by applying the specified encryption algorithm to data composed
of the message and algorithm-specific inputs. Encryption mechanisms defined for use with
Kerberos must take sufficient measures to guarantee the integrity of the plaintext. The
protections often can be enhanced by adding a checksum and a confounder.
The suggested format for the data to be encrypted includes a confounder, a checksum, the
encoded plaintext, and any necessary padding. The msg-seq field contains the part of the
protocol message that is to be encrypted. The format for the data to be encrypted is described
in the following:
{
confounder[0] BYTE STRING(conf_length) OPTIONAL,
check[1] BYTE STRING(checksum_length) OPTIONAL,
msg-seq[2] MsgSequence,
pad BYTE STRING(pad_length) OPTIONAL
}
The first step is to create a confounder. The confounder is a random sequence the same length
as the encryption blocking length. Its purpose is to confuse or confound certain types of brute
force attacks. The second step is to zero out the checksum. Next, calculate the appropriate
checksum over confounder, the zeroed checksum, and the message. Place the result in the
checksum. Add the necessary padding to bring the total length to a multiple of the encryption
blocking length. Encrypt using the specified encryption type and the appropriate key.
Unless otherwise specified, a definition of a Kerberos encryption algorithm uses this ciphertext
format. The ordering of the fields in the ciphertext is important. Additionally, messages
encoded in this format must include a length as part of the message field, to enable the
recipient to verify that the message has not been truncated. Without a length, an attacker
could generate a message that could be truncated, leaving the checksum intact.
To enable all implementations using a particular encryption type to communicate with all
others using that type, the specification of an encryption type defines any checksum needed as
part of the encryption process. If an alternative checksum is to be used, a new encryption type
must be defined.
Some encryption systems require additional information beyond the key and the data to be
encrypted. When DES is used in Cipher Block Chaining mode, for example, it requires an
initialization vector. If required, the description for each encryption type must specify the
source of such additional information.
Encryption Keys
Kerberos maintains a database of active encryption keys. The following structure shows the
encoding of an encryption key:
Kerberos 551
EncryptionKey = {
keytype[0] INTEGER,
keyvalue[1] BYTE STRING
}
n keytype. Specifies the type of encryption key that follows in the keyvalue field. It almost
always corresponds to the encryption algorithm used to generate the encrypted data,
though more than one algorithm may use the same type of key (the mapping is many to
one). This might happen, for example, if the encryption algorithm uses an alternative
checksum algorithm for an integrity check or a different chaining mechanism.
n keyvalue. Contains the key itself, encoded as a byte string.
All negative values for the encryption key type are reserved for local use. All non-negative
values are reserved for officially assigned type fields and interpretations.
Encryption Systems
Kerberos defines a number of encryption systems that may be selected for use in a message. In
addition, it also provides a mechanism for a developer to add his own encryption method.
When a principal sends a message using an encryption method, the destination principal must
also support the encryption method. If it doesn’t, an error message will be returned.
The NULL Encryption System (null)
If no encryption is in use, the encryption system is said to be a NULL encryption system. A
NULL encryption system has no checksum, confounder, or padding. The ciphertext simply is
the plaintext. The NULL encryption system uses the NULL key, which is zero bytes in length
and has keytype zero (0).
DES in CBC Mode with a CRC-32 Checksum (des-cbc-crc)
The des-cbc-crc encryption mode encrypts information under the Data Encryption Standard
using the Cipher Block Chaining (CBC) mode. A CRC-32 checksum is applied to the
confounder and message sequence and placed in the checksum field. The details of the
encryption of this data are identical to those for the des-cbc-md5 encryption mode.
Because the CRC-32 checksum is not collision-proof, different messages can be generated
having the same checksum. An attacker could use a probabilistic chosen plaintext attack to
generate a valid message, even in the face of a confounder. Using collision-proof checksums is
recommended for environments in which such attacks represent a significant threat. Any time
the message will pass through a hostile environment, such as the Internet, or any time the
message has great value, as in financial transactions, a collision-proof checksum should be used.
Note Using the CRC-32 as the checksum for ticket or authenticator no longer is mandated
as an interoperability requirement for Kerberos version 5 Specification 1.
552 Part II: Gaining Access and Securing the Gateway
DES in CBC Mode with an MD4 Checksum (des-cbc-md4)
The des-cbc-md4 encryption mode encrypts information under DES using the Cipher Block
Chaining mode. An MD4 checksum is applied to the confounder and message sequence (msgseq)
and placed in the cksum field. The details of the encryption of this data are identical to
those for the des-cbc-md5 encryption mode.
DES in CBC Mode with an MD5 Checksum (des-cbc-md5)
The des-cbc-md5 encryption mode encrypts information under the Data Encryption Standard
using the Cipher Block Chaining mode. An MD5 checksum is applied to the confounder and
message sequence and placed in the cksum field.
Plaintext and DES ciphertext are encoded as 8-byte blocks that are concatenated to make the
64-bit inputs for the DES algorithms. As a result, the data to be encrypted must be padded to
an 8-byte boundary before encryption.
Encryption under DES using Cipher Block Chaining requires an additional input in the form
of an initialization vector. Unless otherwise specified, zero should be used as the initialization
vector. Kerberos’ use of DES requires an 8-byte confounder.
The DES specifications identify some weak and semi-weak keys. Those keys are not to be used
for encrypting Kerberos messages. Because of the way that keys are derived for the encryption
of checksums, keys shall not be used that yield weak or semi-weak keys when eXclusive-ORed
with the constant F0F0F0F0F0F0F0F0.
A DES key is 8-bytes of data, with keytype one (1). This consists of 56 bits of key, and 8 parity
bits (one per byte).
To generate a DES key from a password, the password normally must have the Kerberos realm
name and each component of the principal’s name appended, then padded with ASCII nulls to
an 8-byte boundary. This string is then fan-folded and eXclusive-ORed with itself to form an
8-byte DES key. The parity is corrected on the key, and it is used to generate a DES-CBC
checksum on the initial string (with the realm and name appended). Next, parity is corrected
on the CBC checksum. If the result matches a “weak” or “semi-weak” key as described in the
DES specification, it is eXclusive-ORed with the constant 00000000000000F0. Finally, the
result is returned as the key.
Checksums
The following structure is used for a checksum:
Checksum = {
cksumtype[0] INTEGER,
checksum[1] BYTE STRING
}
Kerberos 553
n cksumtype. Indicates the algorithm used to generate the accompanying checksum.
n checksum. Contains the checksum itself, encoded as byte string.
Negative values for the checksum type are reserved for local use. All non-negative values are
reserved for officially assigned type fields and interpretations.
Kerberos supports a variety of checksums. In addition, specific implementations may also
support implementation-specific checksums. The following sections describe the standard
checksums supported by Kerberos. Selection of a specific checksum is up to the application
providing the information.
Note Kerberos uses checksums that can be classified by two properties: whether they’re
collision-proof and whether they’re keyed.
A checksum is said to be collision-proof if finding two plaintexts that generate the same
checksum value is infeasible. This means that it is not possible for someone to change a
message in a manner that leaves the checksum unchanged. Any change to the message makes
an unpredictable change to the checksum.
A keyed checksum requires a key to perturb or initialize the algorithm. Keyed checksums are
usually cryptographically based. This makes them collision-proof, because the randomizing
effect of the encryption makes it impossible to predict the change to the checksum of any
change in the message.
To prevent message-stream modification by an active attacker, unkeyed checksums should be
used only when the checksum and message will be subsequently encrypted. For example, the
checksums defined as part of the encryption algorithms covered earlier in this section are
encrypted.
Collision-proof checksums can be made tamperproof as well if the checksum value is encrypted
before inclusion in a message. In such cases, combining the checksum and the encryption
algorithm is considered a separate checksum algorithm. RSA-MD5 encrypted using DES is a
new checksum algorithm of type RSA-MD5-DES. For most keyed checksums, as well as for
the encrypted forms of collision-proof checksums, Kerberos prepends a confounder before
calculating the checksum.
The CRC-32 Checksum (crc32)
The CRC-32 checksum calculates a checksum based on a cyclic redundancy check as described
in ISO 3309. The resulting checksum is four bytes long. The CRC-32 is neither keyed nor
collision-proof. Using this checksum is not recommended, because an attacker might be able
to generate an alternative message that satisfies the checksum. Use collision-proof checksums
for environments in which such attacks represent a significant threat such as the Internet, or an
application with high value information.
554 Part II: Gaining Access and Securing the Gateway
The RSA MD4 Checksum (rsa-md4)
The RSA-MD4 checksum uses the RSA MD4 algorithm to calculate a checksum. The
algorithm takes a message of arbitrary length as input and outputs a 128-bit (16-byte)
checksum. RSA-MD4 is collision-proof.
RSA MD4 Cryptographic Checksum Using DES (rsa-md4-des)
The RSA-MD4-DES checksum calculates a keyed collision-proof checksum and requires an
8-byte confounder before the text. The calculation applies the RSA MD4 checksum algorithm,
and encrypts the confounder and the checksum using DES in Cipher Block Chaining (CBC)
mode. It uses a variant of the session key, where the variant is computed by eXclusive-ORing
the key with the constant F0F0F0F0F0F0F0F0. A variant of the key is used to limit the use of
a key to a particular function, separating the function of generating a checksum from other
encryption performed using the session key. The constant F0F0F0F0F0F0F0F0 was chosen
because it maintains key parity. The initialization vector should be zero. The resulting
checksum is 24 bytes long, 8 bytes of which are redundant. This checksum is tamperproof
and collision-proof.
The RSA MD5 Checksum (rsa-md5)
The RSA-MD5 checksum uses the RSA MD5 algorithm to calculate a checksum. The
algorithm takes a message of arbitrary length as input and outputs a 128-bit (16-byte)
checksum. RSA-MD5 is collision-proof.
RSA MD5 Cryptographic Checksum Using DES (rsa-md5-des)
The RSA-MD5-DES checksum calculates a keyed collision-proof checksum, the same way the
RSA-MD4-DES checksum is calculated, except using RSA-MD5 rather than RSA-MD4. The
resulting checksum is 24 bytes long, 8 bytes of which are redundant. This checksum is tamperproof
and collision-proof.
DES Cipher Block Chained Checksum (des-mac)
The DES-MAC checksum is computed by prepending an 8-byte confounder to the plaintext
and using the session key to perform a DES CBC-mode encryption on the result. The initialization
vector should be zero. It encrypts the same confounder and the last 8-byte block of the
ciphertext using DES in Cipher Block Chaining mode and a variant of the key as described in
rsa-md4-des. The initialization vector should be zero. The resulting checksum is 128 bits (16
bytes) long, 64 bits of which are redundant. This checksum is tamperproof and collision-proof.
RSA MD4 Cryptographic Checksum Using DES Alternative
(rsa-md4-des-k)
The RSA-MD4-DES-K checksum calculates a keyed collision-proof checksum. It uses the RSA
MD4 checksum algorithm and encrypts the result using DES in Cipher Block Chaining mode.
Kerberos 555
The DES key is used as both key and initialization vector. The resulting checksum is 16 bytes
long. This checksum is tamperproof and collision-proof. This checksum type is the old
method for encoding the RSA-MD4-DES checksum and is no longer recommended. It is
supported to provide backward compatibility.
DES Cipher-Block Chained Checksum Alternative (des-mac-k)
The DES-MAC-K checksum is computed by performing a DES CBC-mode encryption of the
plaintext. The last block of the ciphertext is used as the checksum value. It is keyed with an
encryption key and an initialization vector. Any uses that do not specify an additional initialization
vector will use the key as both key and initialization vector. The resulting checksum is
64 bits (8 bytes) long. This checksum is tamperproof and collision-proof. This checksum type
is the old method for encoding the DES-MAC checksum and is no longer recommended. It is
supported to provide backward compatibility.
Versions of Kerberos
Several different versions and distributions of Kerberos are available. Most of them are based
on MIT distributions in one form or another, but the lineage isn’t always simple to trace. The
newest version of MIT Kerberos is version 5. Versions 4 and 5 are based on completely
different protocols. The MIT Kerberos version 5 distribution contains some compatibility
code to support conversion from version 4:
n The Kerberos version 5 server can optionally service version 4 requests.
n A program enables users to convert a version 4 format Kerberos database to a version 5
format database.
n An administration server that accepts version 4 protocol and operates on a version 5
database.
Some distributions are freely available, some are stand-alone commercial products, and others
are part of a larger free or commercial system.
Versions of Kerberos Version 4
There are several VERSION 4 distributions available. Because version 4 is not totally compatible
with version 5, organizations starting new Kerberos installations should consider starting
at version 5.
MIT Kerberos Version 4 Availability
MIT version 4 is freely available in the U.S. and Canada through anonymous FTP from
athena-dist.mit.edu (18.71.0.38). For specific instructions, change to the pub/Kerberos
556 Part II: Gaining Access and Securing the Gateway
directory and download the file README.KRB4 (for version 4) or README.KRB5 (for
version 5), both of which are text files that explain the export restrictions and contain detailed
instructions on how to download the source code via anonymous FTP. Locations outside
North America may use the Bones version.
Transarc Kerberos
A second distribution of Kerberos version 4 is available as a commercial product from
Transarc. Years ago, the designers of AFS decided to implement their own security system
based on the Kerberos specification rather than using MIT Kerberos version 4, which then was
not publicly available. Consequently, Transarc’s AFS Kerberos speaks a slightly different
protocol but also understands the MIT Kerberos version 4 protocol. They can, in principal,
talk to each other. Enough annoying incompatible details, however, make it impractical.
DEC Ultrix Kerberos
A third distribution of Kerberos version 4 is available from Digital Equipment Corporation.
Aside from a few changes, DEC’s commercial version essentially matches MIT Kerberos
version 4.
Versions of Kerberos Version 5
Version 5 of Kerberos is the most recent version. Changes in the protocol have solved a
number of security problems from version 4.
MIT Kerberos Version 5
MIT Kerberos version 5 is freely available and is available from the same site as version 4 MIT
via anonymous FTP from athena-dist.mit.edu (18.71.0.38).
OSF DCE Security
The Open Systems Foundation (OSF) has defined a Distributed Computing Environment
(DCE) with security based on Kerberos version 5, and using the same wire protocol. However,
applications from two systems use the protocol in different ways, so the actual interoperability
between Kerberos and DCE is limited. Because DCE is defined as an open standard, it is up to
manufacturers to provide products that fit into that standard. More and more manufacturers
are providing DCE-compliant products, and it is now possible to assemble a complete DCEcompliant
security environment by selecting DCE-compliant vendors.
Bones
Kerberos is a network security system that relies on cryptographic methods for its security.
Because Kerberos’ encryption system, DES, cannot be exported, Kerberos itself cannot be
Kerberos 557
exported or used outside the United States and Canada in its original form. Bones is a system
that provides the Kerberos API without using encryption and without providing any form of
security—it’s a fake that enables the use of software that expects Kerberos to be present when it
cannot be.
Note Bones possesses the property of there being absolutely no question about its legality
concerning transportation of its source code across national boundaries. It neither
has any encryption routines nor any calls to encryption routines.
You can obtain a working copy of Bones through anonymous FTP from ftp.funet.fi
(128.214.6.100) in pub/unix/security/kerberos. A DES library is available at the same location.
SESAME
SESAME is an initiative of the European community to produce a compatible product to
Kerberos version 5. SESAME-compatible systems are accessible through Kerberos and vice
versa. SESAME makes use of DES software developed outside North America, and is not
subject to export restrictions. Information on SESAME is available from http://
www.esat.kuleuven.ac.be/cosic/sesame3.html.
Selecting a Vendor
The following vendors currently have Kerberos offerings:
CyberSAFE
Cygnus Support
Digital Equipment Corporation
Emulex Network Systems
OpenVision Technologies, Inc.
TGV, Inc.
When looking for a vendor, you need to consider more than just software offerings. Because
Kerberos installations tend to require a considerable amount of customization, you should
inspect consulting support. In a typical Kerberos installation, you can expect to run into
compatibility problems with the underlying operating systems of the servers, and possibly with
the applications you want to protect. A good consultant who has experience installing Kerberos
can greatly improve your chance of completing the project on time and within budget.
558 Part II: Gaining Access and Securing the Gateway
Vendor Interoperability Issues
Not all vendors have implemented Kerberos in the same manner. The result is that products
from different vendors do not always talk to each other. This is less of a problem with version
5 than version 4, but it remains an issue of concern for any organization considering a
Kerberos installation.
DEC ULTRIX Kerberos
DEC ULTRIX contains Kerberos for a single reason, namely, to provide authenticated name
service for the ULTRIX enhanced security option. It does not support Kerberos user-level
authentication.
DEC’s version essentially is the same as, and is derived from, MIT Kerberos version 4, except
for a few changes. A version 5 is due out about the same time as this book. The most significant
change is that the capability to perform any kind of end-to-end user data encryption has
been eliminated to comply with export restrictions. Minor changes include the placement of
ticket files (/var/dss/kerberos/tkt versus /tmp) and the principal names used by some standard
Kerberos services (for example, kprop versus rcmd). Some other minor changes probably have
been made as well.
Although you can use DEC ULTRIX Kerberos in the normal way, no reason to do so exists,
because the MIT distribution supports ULTRIX directly.
Transarc’s Kerberos
Transarc’s Kerberos uses a different string-to-key function (the algorithm that turns a password
into a DES key) than MIT Kerberos. The AFS version uses the realm name as part of the
computation, whereas the MIT version does not. A program that uses a password to acquire a
ticket (for example, kinit or login) works only with one version, unless modified to try both
string-to-key algorithms.
Transarc also uses a different method of finding Kerberos servers. MIT Kerberos uses krb.conf
and krb.realms to map hostnames to realms and realms to Kerberos servers. AFS servers for
a realm are located on the AFS database servers and can be located using /usr/vice/etc/
CellServDB. This means that a program built using the MIT Kerberos libraries looks in one
place for the information while a program built using the AFS Kerberos libraries looks in
another. You can set up all three files and use both libraries, but be sure that everything is
consistent among the different files.
The two versions have a different password-changing protocol, so you must use the correct
“kpasswd” program for the server with which you connect. In general, AFS clients that talk
directly to the kaserver use an Rx-based protocol, instead of UDP with MIT Kerberos, so those
AFS clients cannot talk to an MIT server.
Kerberos 559
In summary, AFS Kerberos and MIT Kerberos can interoperate after you acquire a Ticket
Granting Ticket, which you can do with kinit (MIT) or klog (AFS). With a Ticket Granting
Ticket, Kerberos applications such as rlogin can talk to an MIT or AFS Kerberos server and
achieve correct results. However, it is probably best to pick one implementation and use it
exclusively. It will reduce the administration problems.
DCE
DCE Security started from an early alpha release of version 5 and the two versions have
developed independently. MIT and the OSF have agreed to resolve some minor incompatibilities.
The DCE Security Server, secd, listens on UDP port 88 for standard Kerberos requests and
responds appropriately. Therefore, clients of MIT Kerberos can operate in a DCE environment
without modification, assuming the DCE Security database contains the appropriate
principals with the correct keys.
An MIT Kerberos version 5 server cannot replace the DCE Security Server. First, DCE
applications communicate with secd by way of the DCE RPC. Second, the DCE Security
model includes a Privilege Server that fills in the authorization field of a principal’s ticket with
DCE-specific data, and the DCE Security Server has a built-in Privilege Server. Before the
MIT Kerberos version 5 server can support DCE clients it needs to talk to a stand-alone
Privilege Server and no such Privilege Server presently exists, although the necessary information
is available.
As an additional complication, the DCE does not officially export the Kerberos version 5 API.
It only exports a DCE Security-specific API. Individual vendors can provide the Kerberos
version 5 API if they want, but unless they all do (which seems unlikely) Kerberos version 5
API applications will not be compile-time portable to pure DCE environments. Only binaries
will work with both versions.
Interoperability Requirements
Version 5 of the Kerberos protocol supports a myriad of options, including multiple encryption
and checksum types, alternative encoding schemes, optional mechanisms for preauthentication,
the handling of tickets with no addresses, options for mutual authentication,
user-to-user authentication, support for proxies, forwarding, postdating and renewing tickets,
formatting realm names, and handling authorization data.
You must define a minimal configuration that all implementations support to ensure the
interoperability of realms. This minimal configuration is subject to change as technology does.
If it is discovered at some later date that one of the required encryption or checksum algorithms
is not secure, for example, it will be replaced.
560 Part II: Gaining Access and Securing the Gateway
Specification 1
Specification 1 is the first definition of a standard set of these options. Implementations
configured in this way are said to support Kerberos version 5 Specification 1.
Encryption and Checksum Methods
The following encryption and checksum mechanisms must be supported. Implementations
may support other mechanisms as well, but the additional mechanisms may only be used when
communicating with principals also known to support them:
Encryption: DES-CBC-MD5
Checksums:CRC-32, DES-MAC, DES-MAC-K, and DES-MD5
Realm Names
All implementations must understand hierarchical realms in both the Internet domain and the
X.500 style. When a Ticket Granting Ticket for an unknown realm is requested, the Key
Distribution Center must be able to determine the names of the intermediate realms between
the Key Distribution Center’s realm and the requested realm.
Transited Field Encoding
DOMAIN-X500-COMPRESS must be supported. Alternative encodings may be supported,
but they may be used only when all intermediate realms support that encoding.
Preauthentication Methods
The TGS-REQ method must be supported. The TGS-REQ method is not used on the initial
request. Clients must support the PA-ENC-TIMESTAMP method, but whether it is enabled
by default may be determined per realm. If not used in the initial request, and the error
KDC_ERR_PREAUTH_REQUIRED is returned specifying PA-ENC-TIMESTAMP as an
acceptable method, the client should retry the initial request using the PA-ENCTIMESTAMP
preauthentication method. Servers need not support the PA-ENCTIMESTAMP
method, but if not supported, the server should ignore the presence
of PA-ENC-TIMESTAMP preauthentication in a request.
Mutual Authentication
Mutual authentication (via the KRB_AP_REP message) must be supported.
Ticket Addresses and Flags
All Key Distribution Centers must pass on tickets that carry no addresses. If a Ticket Granting
Ticket contains no addresses, the Key Distribution Center returns derivative tickets. Each
Kerberos 561
realm may set its own policy for issuing such tickets, and each application server sets its own
policy concerning accepting them. By default, servers should not accept them.
Proxies and forwarded tickets must be supported. Individual realms and application servers can
set their own policy regarding when such tickets are accepted.
All implementations must recognize renewable and postdated tickets, but need not actually
implement them. If these options are not supported, the start time and end time in the ticket
specify a ticket’s entire useful life. When a server decodes a postdated ticket, all implementations
make the presence of the postdated flag visible to the calling server.
User-to-User Authentication
Support for user-to-user authentication, via the ENC-TKTIN-SKEY Key Distribution Center
option, is required. Individual realms can decide as a matter of policy to reject such requests on
a per-principal or realm-wide basis.
Authorization Data
Implementations must pass all authorization data subfields from Ticket Granting Tickets to
any derivative tickets unless directed to suppress a subfield as part of the definition of that
registered subfield type. Passing on a subfield is never correct, and no registered subfield types
presently specify suppression at the Key Distribution Center.
Implementations must make the contents of any authorization data subfields available to the
server when a ticket is used. Implementations are not required to permit clients to specify the
contents of the authorization data fields.
Recommended Key Distribution Center Values
The following list supplies recommended values for a Key Distribution Center implementation,
based on the list of suggested configuration constants:
Minimum lifetime 5 minutes
Maximum renewable lifetime 1 week
Maximum ticket lifetime 1 day
Empty addresses Permitted only when suitable restrictions appear in
authorization data
Naming Constraints
Kerberos has several different types of names. Each type of name has its own rules, structure,
and limitations.
562 Part II: Gaining Access and Securing the Gateway
Realm Names
Although realm names are encoded as GeneralStrings and although a realm technically can
select any name it chooses, interoperability across realm boundaries requires agreement on how
realm names are to be assigned and what information they imply.
To enforce these conventions, each realm must conform to the conventions. It must require
that any realms with which inter-realm keys are shared also conform to the conventions and
require the same from its neighbors.
Presently, the four styles of realm names are domain, X.500, other, and reserved. Examples of
each style follow:
domain: host.subdomain.domain
X500: C=US/O=OSF
other: NAMETYPE:rest/of.name=without-restrictions
reserved: reserved, but will not conflict with above
The most common type of name in use is the domain name. Domain names must look like
Internet domain names. They consist of components separated by periods (.) and contain
neither colons (:) nor slashes (/).
Some organizations use X.500 names to remain consistent with other naming conventions in
use within the organization. X.500 names contain an equal sign (=) and cannot contain a colon
(:) before the equal sign. The realm names for X.500 names are string representations of the
names with components separated by slashes (leading and trailing slashes not included).
In case your organization wants to use an unusual naming convention, Kerberos allows for
implementation-specific naming systems. Names that fall into the other category must begin
with a prefix that contains no equal sign (=) or period (.) and the prefix must be followed by a
colon (:) and the rest of the name. All prefixes must be assigned before they may be used.
Presently none are assigned.
Finally, a category of names is left for future use. The reserved category includes strings that
do not fall into the first three categories. All names in this category are reserved. Names are
unlikely to be assigned to this category unless a very strong argument exists for not using the
“other” category.
These rules guarantee no conflicts between the various name styles. The following additional
constraints apply to assigning realm names in the domain and X.500 categories. The name of a
realm for the domain or X.500 formats must be used by organizations that own an Internet
domain name or X.500 name. If no such names are registered, authority to use a realm name
may be derived from the authority of the parent realm. If E40.MIT.EDU lacks a domain
name, for example, the administrator of the MIT.EDU realm can authorize the creation of a
realm of that name.
Kerberos 563
This is acceptable because the organization to which the parent is assigned presumably is the
organization authorized to assign names to its children in the X.500 and domain name systems
as well. If the parent assigns a realm name without also registering it in the domain name or
X.500 hierarchy, the parent is responsible for ensuring that a name identical to the realm name
of the child does not exist in the future unless assigned to the child.
Principal Names
As was the case for realm names, conventions are needed to ensure that all agree on what
information is implied by a principal name. The name-type field that is part of the principal
name indicates the kind of information implied by the name. The name type should be treated
as a hint. Ignoring the name type, no two names can be the same. At least one of the components,
or the realm, must be different. An example of a principal name is a username of
JSmith. It would have a type of NT-PRINCIPAL, and the realm name of
RESEARCH.ABC.COM (domain name style) would be considered to be a part of the
principal name. The following name types are defined:
Name Type Value Meaning
NT-UNKNOWN 0 Name type not known
NT-PRINCIPAL 1 Just the name of the principal as in DCE, or for users
NT-SRV-INST 2 Service and other unique instance (krbtgt)
NT-SRV-HST 3 Service with host name as instance (telnet,
rcommands)
NT-SRV-XHST 4 Service with host as remaining components
NT-UID 5 Unique ID
When a name implies no information other than its uniqueness at a particular time, the name
type PRINCIPAL should be used. The principal name type should be used for users, and it
also might be used for a unique server. If the name is a unique machine-generated ID guaranteed
never to be reassigned, then the name type of UID should be used. Reassigning names
of any type generally is a bad idea because stale entries might remain in Access Control Lists.
Reassigned names could acquire rights to information that were not intended. This problem is
called object reuse because the new owner of the name gets to use the information as a result of
the previous owner of the name having rights to use the object.
If the first component of a name identifies a service and the remaining components identify an
instance of the service in a server-specified manner, then the name type of SRV-INST should
be used. An example of this name type is the Kerberos Ticket Granting Ticket that has a first
component of krbtgt and a second component that identifies the realm for which the ticket is
valid.
564 Part II: Gaining Access and Securing the Gateway
If an instance is a single component following the service name and the instance identifies the
host on which the server is running, then the name type SRV-HST should be used. This type
typically is used for Internet services such as Telnet and the Berkeley R commands. If the
separate components of the host name appear as successive components following the name of
the service, then the name type SRVXHST should be used. This type might be used to identify
servers on hosts with X.500 names where the slash (/) might otherwise be ambiguous.
A name type of UNKNOWN should be used when the form of the name is not known. When
comparing names, a name type of UNKNOWN matches principals authenticated with names
of any type. A principal authenticated with a name type of UNKNOWN, however, matches
only other names type of UNKNOWN.
Name of Server Principals
The principal identifier for a server on a host generally is composed of the following two parts:
n The realm of the Key Distribution Center with which the server is registered
n A two-component name of type NT-SRV-HST if the host name is an Internet domain
name, or a multicomponent name of type NT-SRV-XHST if the name of the host is of a
form that permits slash (/) separators, such as X.500
The first component of the multicomponent name identifies the service and the latter components
identify the host. Where the name of the host is not case-sensitive (for example, with
Internet domain names), the name of the host must be lowercase. For services such as Telnet
and the Berkeley R commands that run with system privileges, the first component is the
string “host” rather than a service-specific identifier.
Cross-Realm Operation
The Kerberos protocol is designed to operate across organizational boundaries. A client in one
organization can be authenticated to a server in another. Each organization that wants to run a
Kerberos server establishes its own realm. The name of the realm in which a client is registered
is part of the client’s name, and can be used by the end-service to decide whether to honor a
request.
By establishing inter-realm keys, the administrators of two realms can enable a client authenticated
in the local realm to use its authentication remotely. With appropriate permission, the
client could arrange registration of a separately named principal in a remote realm and engage
in normal exchanges with that realm’s services. For even small numbers of clients, however,
this becomes cumbersome, and more automatic methods are necessary. The exchange of interrealm
keys (a separate key may be used for each direction) registers the Ticket Granting Service
of each realm as a principal in the other realm. A client then can obtain a Ticket Granting
Kerberos 565
Ticket for the remote realm’s Ticket Granting Service from its local realm. When that Ticket
Granting Ticket is used, the remote Ticket Granting Service uses the inter-realm key, which
usually differs from its own normal Ticket Granting Server key, to decrypt the Ticket Granting
Ticket. It thereby can be certain that it was issued by the client’s own Ticket Granting Server.
Tickets issued by the remote Ticket Granting Service let the end-service know that the client
was authenticated from another realm.
A realm is said to communicate with another realm if the two realms share an inter-realm key
or if the local realm shares an inter-realm key with an intermediate realm that communicates
with the remote realm. An authentication path is the sequence of intermediate realms transited
in communicating from one realm to another.
Realms typically are organized hierarchically. Each realm shares a key with its parent and a
different key with each child. If an inter-realm key is not directly shared by two realms, the
hierarchical organization permits an authentication path to be constructed. If a hierarchical
organization is not used, it might be necessary to consult some database before constructing an
authentication path between realms is possible. If there is regular communication between two
realms that are not directly connected in the hierarchy, they can set up a direct key between
the two realms. Figure 9.3 shows a corporate hierarchy with the links between systems
representing a connection with a shared key. Note that there is a direct connection between
ProjectW.RESEARCH.ABC.COM and ProjectW.PAYROLL.ABC.COM. Any time a
connection will see significant data flows, an inter-realm key can be created and shared
between the servers.
ABC.COM
Production Research Accounting Payroll
ProjectW ProjectX ProjectW ProjectX
Figure 9.3
A corporate hierarchy with
shared key.
Although realms typically are hierarchical, intermediate realms can be bypassed to achieve
cross-realm authentication through alternative authentication paths. These might be established
to make communication between two realms more efficient. The end-service needs to
know which realms were transited when deciding how much faith to place in the authentication
process. To facilitate this decision, a field in each ticket contains the names of the realms
involved in authenticating the client.
566 Part II: Gaining Access and Securing the Gateway
Ticket Flags
Each Kerberos ticket contains a set of bit flags that are used to indicate attributes of that ticket.
Most flags can be requested by a client when the ticket is obtained. Some are turned on and off
automatically by a Kerberos server as required. The following sections explain what the various
flags mean, and give examples of reasons to use such a flag.
Table 9.1 describes the ticket flags.
Table 9.1
Ticket Flags
Bit(s) Name Description
0 RESERVED Reserved for future expansion.
1 FORWARDABLE This flag tells the Ticket Granting Server that it is OK
to issue a new Ticket Granting Ticket with a different
network address based on the presented ticket.
2 FORWARDED This flag indicates that the ticket has either been
forwarded or was issued based on authentication
involving a forwarded Ticket Granting Ticket.
3 PROXIABLE The PROXIABLE flag has an interpretation identical
to that of the FORWARDABLE flag, except that the
PROXIABLE flag tells the Ticket Granting Server that
only non-Ticket Granting Tickets may be issued with
different network addresses.
4 PROXY When set, this flag indicates that a ticket is a proxy.
5 MAY-POSTDATE This flag tells the Ticket Granting Server that a post
dated ticket may be issued based on this Ticket
Granting Ticket.
6 POSTDATED This flag indicates that this ticket has been postdated.
7 INVALID This flag indicates that a ticket must be validated
before use.
8 RENEWABLE A renewable ticket can be used to obtain a replacement
ticket that expires at a later date.
9 INITIAL This flag indicates that this ticket was issued using the
Authentication Server protocol, and not issued based
on a Ticket Granting Ticket.
Kerberos 567
10 PRE-AUTHENT This flag indicates that during initial authentication,
the client was authenticated by the Key Distribution
Center before a ticket was issued.
11 HW-AUTHENT This flag indicates that the protocol employed for
initial authentication required the use of hardware
expected to be possessed solely by the named client.
12–31 RESERVED Reserved for future use.
Initial and Preauthenticated Tickets
The INITIAL flag indicates that a ticket was issued using the Authentication Server protocol
and not issued based on a Ticket Granting Ticket. Application servers that want to require the
knowledge of a client’s secret key (for example, a password changing program) can insist that
this flag be set in any tickets they accept. Thus, they are assured that the client’s key was
recently presented to the application client.
Invalid Tickets
The INVALID flag indicates that a ticket is invalid. Application servers must reject tickets that
have this flag set. A postdated ticket usually is issued in this form. Invalid tickets must be
validated by the Key Distribution Center before use, by presenting them to the Key Distribution
Center in a Ticket Granting Server request with the VALIDATE option specified. The
Key Distribution Center will validate tickets only after their start time has passed. Thus, the
validation is required so that postdated tickets that have been stolen before their start time can
be rendered permanently invalid using a hot-list mechanism.
Renewable Tickets
Applications might want to hold tickets that can be valid for long periods of time. This can
expose their credentials to potential theft for equally long periods and those stolen credentials
would be valid until the expiration time of the ticket(s). Simply using short-lived tickets and
obtaining new ones periodically would require the client to have long-term access to its secret
key, an even greater risk.
The solution to this problem is a renewable ticket. Renewable tickets can be used to mitigate
the consequences of theft. Renewable tickets have two expiration times. The first is when the
current instance of the ticket expires and the second is the latest permissible value for an
individual expiration time. An application client must present a renewable ticket to the Key
Distribution Center before it expires. The ticket is presented with the RENEW option set in
Bit(s) Name Description
568 Part II: Gaining Access and Securing the Gateway
the Key Distribution Center request. The Key Distribution Center issues a new ticket with a
new session key and a later expiration time. All other fields of the ticket are left unmodified by
the renewal process. When the latest permissible expiration time arrives, the ticket expires
permanently. At each renewal, the Key Distribution Center can consult a hot-list to determine
if the ticket had been reported stolen since its last renewal. It refuses to renew such stolen
tickets, thereby reducing the usable lifetime of stolen tickets.
The RENEWABLE flag in a ticket normally is interpreted only by the Ticket Granting
Service. Application servers usually can ignore it. Some particularly careful application
servers, however, might want to disallow renewable tickets.
If a renewable ticket is not renewed by its expiration time, the Key Distribution Center will
not renew the ticket. The RENEWABLE flag is reset by default, but a client can request it be
set by setting the RENEWABLE option in the KRB_AS_REQ message. If it is set, then the
renew-till field in the ticket contains the time after which the ticket may not be renewed.
A renewable ticket will be used when a user wants to run a particularly long process. Because
the application will run for longer than the local policy allows a single ticket to live, the
application will request a renewable ticket. As the simulation is running, the application will
occasionally request the Key Distribution Center to renew the ticket. This verifies that the
workstation controlling the simulation has not been listed as compromised.
Postdated Tickets
Applications occasionally might need to obtain tickets for use much later. A batch submission
system, for example, would need tickets to be valid at the time the batch job is serviced.
Holding valid tickets in a batch queue is dangerous, however, because they stay online longer,
becoming more prone to theft. Postdated tickets provide a way to obtain these tickets from the
Key Distribution Center at job submission time, but to leave them dormant until they are
activated and validated by a further request of the Key Distribution Center. If a ticket theft
were reported in the interim, the Key Distribution Center would refuse to validate the ticket,
and the thief would be foiled.
The MAY-POSTDATE flag in a ticket normally is interpreted only by the Ticket Granting
Service. Application servers can ignore it. This flag must be set in a Ticket Granting Ticket in
order to issue a postdated ticket based on the presented ticket. It is reset by default. A client
can request it by setting the ALLOW-POSTDATE option in the KRB_AS_REQ message.
This flag does not permit a client to obtain a postdated Ticket Granting Ticket. Postdated
Ticket Granting Tickets can be obtained only by requesting the postdating in the
KRB_AS_REQ message.
When a postdated ticket is issued, the life (end time-start time) of the ticket is the remaining
life of the ticket-granting ticket at the time of the request, unless the RENEWABLE option
also is set, in which case it can be the full life (end time-start time) of the Ticket Granting
Ticket. The Key Distribution Center can limit how far in the future a ticket may be postdated.
Kerberos 569
The POSTDATED flag indicates that a ticket has been postdated. The application server can
check the authtime field in the ticket to see when the original authentication occurred. Some
services might reject postdated tickets, or accept them only within a certain period after the
original authentication. When the Key Distribution Center issues a POSTDATED ticket, it
also is marked as INVALID, so that the application client must present the ticket to the Key
Distribution Center to be validated before use.
Proxiable and Proxy Tickets
Sometimes, a principal might need to enable a service to perform an operation on its behalf.
The service must be able to take on the identity of the client, but only for a particular purpose.
A principal can permit a service to take on the principal’s identity for a particular purpose by
granting it a proxy.
The PROXIABLE flag in a ticket normally is interpreted only by the Ticket Granting Service.
Application servers can ignore it. When set, this flag gives the Ticket Granting Server the go
ahead to issue a new ticket (but not a Ticket Granting Ticket) with a different network address
based on this ticket. This flag is set by default. This flag enables a client to pass a proxy to a
server to perform a remote request on its behalf. A print service client, for example, can give
the print server a proxy to access the client’s files on a particular file server to satisfy a print
request.
To complicate the use of stolen credentials, Kerberos tickets usually are valid only from those
network addresses specifically included in the ticket. You can request or issue tickets with no
network addresses specified, but doing so is not recommended. Therefore, a client that wants
to grant a proxy must request a new ticket valid for the network address of the service to be
granted the proxy.
The PROXY flag is set in a ticket by the Ticket Granting Server when it issues a proxy ticket.
Application servers may check this flag and require additional authentication from the agent
before presenting the proxy in order to provide an audit trail.
Forwardable Tickets
Authentication forwarding is an instance of the proxy case where the service is granted
complete use of the client’s identity. A user might log in to a remote system, for example, and
want authentication to work from that system as if the login were local.
The FORWARDABLE flag in a ticket normally is interpreted only by the Ticket Granting
Service. Application servers can ignore it. The FORWARDABLE flag has an interpretation
similar to that of the PROXIABLE flag, except Ticket Granting Tickets also can be issued
using different network addresses. This flag is reset by default, but users can request that it be
set by setting the FORWARDABLE option in the Authentication Server request when they
request the initial Ticket Granting Ticket.
570 Part II: Gaining Access and Securing the Gateway
When set, the FORWARDABLE flag permits authentication forwarding without requiring
the user to reenter a password. If the flag is not set, then authentication forwarding is not
permitted. The same end result still can be achieved if the user engages in the Authentication
Server exchange with the requested network addresses and supplies a password.
The FORWARDED flag is set by the Ticket Granting Server when a client presents a ticket
with the FORWARDABLE flag set and requests it be set by specifying the FORWARDED
Key Distribution Center option and supplying a set of addresses for the new ticket. It also is
set in all tickets issued based on tickets with the FORWARDED flag set. Application servers
might want to process FORWARDED tickets differently from non-FORWARDED tickets.
Authentication Flags
Three flags indicate information about the user’s authentication status. INITIAL, PREAUTHENT,
and HW-AUTHENT are set at the time of authentication.
INITIAL is set by the Authentication Server whenever a ticket is issued as a result of an
authentication. This flag does not carry forward onto future tickets, so it serves to indicate that
this ticket was authenticated directly, which is useful for applications that require a specific
authentication prior to proceeding, such as the login or password changing programs.
Note Some of the possible Kerberos startup cycles can result in a ticket being issued
before the user is authenticated. These tickets should be usable only by the legitimate
user. The PRE-AUTHENT flag is set after a specific authentication takes place.
Finally, the flag HW-AUTHENT indicates that the user was hardware authenticated. Hardware
authentication through the use of tokens or biometrics generally is stronger than simple
password authentication. Applications dealing with particularly sensitive information or large
financial transactions might want to insist on a hardware authentication.
Other Key Distribution Center Options
Two additional options can be set in a client’s request of the Key Distribution Center. The
RENEWABLE-OK option indicates that the client will accept a renewable ticket if a ticket
with the requested life cannot otherwise be provided. If a ticket with the requested life cannot
be provided, then the Key Distribution Center can issue a renewable ticket with a renew-till
equal to the requested end time. The value of the renew-till field still can be adjusted by sitedetermined
limits or limits imposed by the individual principal or server.
The ENC-TKT-IN-SKEY option is honored only by the Ticket Granting Service. It indicates
that the to-be-issued ticket for the end server is to be encrypted in the session key from the
additional Ticket Granting Ticket provided with the request.
Kerberos 571
Message Exchanges
Every time a new application is started, or a new session is established, the Kerberosized
applications communicate with the client to authenticate the user. The following sections
describe the interactions between network clients and servers and the messages involved in
those exchanges.
Tickets and Authenticators
This section describes the format and encryption parameters for tickets and authenticators.
When a ticket or authenticator is included in a protocol message, it is treated as an opaque
object.
Tickets
A ticket is a record that helps a client authenticate to a service. A ticket contains the following
information:
Ticket = {
tkt-vno[0] INTEGER,
realm[1] Realm,
sname[2] Principal Name,
enc-part[3] EncryptdData
}
— Encrypted part of ticket
EncryptdData = {
flags[0] Ticket Flags,
key[1] EncryptionKey,
crealm[2] Realm,
cname[3] Principal Name,
transited[4] Transited Encoding,
authtime[5] KerberosTime,
starttime[6] KerberosTime OPTIONAL,
endtime[7] KerberosTime,
renew-till[8] KerberosTime OPTIONAL,
caddr[9] HostAddresses OPTIONAL,
authorization-data[10] AuthorizationData OPTIONAL
}
— encoded Transited field
TransitedEncoding = {
tr-type[0] INTEGER — must be registered
contents[1] BYTE STRING
}
572 Part II: Gaining Access and Securing the Gateway
The encoding of EncryptdData is encrypted in the key shared by Kerberos and the end server
(the server’s secret key). Table 9.2 describes the fields in the ticket.
Table 9.2
Ticket Field Descriptions
Field Description
tkt-vno Specifies the version number of the ticket.
realm Specifies the realm that issued the ticket. Also serves to identify the
realm part of the server’s principal identifier. Because a Kerberos server
can issue tickets only for servers within its realm, the two always are
identical.
sname Specifies the name part of the server’s identity.
enc-part Holds the encrypted encoding of the EncryptdData sequence.
flags Indicates which of various options were used or requested when the
ticket was issued.
key Exists in the ticket and the Key Distribution Center response and is
used to pass the session key from Kerberos to the application server and
the client.
crealm Contains the name of the realm in which the client is registered and in
which initial authentication took place.
cname Contains the name part of the client’s principal identifier.
transited Lists the names of the Kerberos realms that took part in authenticating
the user to whom this ticket was issued.
authtime Indicates the time of initial authentication for the named principal.
Serves as the time of issue for the original ticket on which this ticket is
based. Included in the ticket to provide additional information to the
end service.
starttime Specifies the time after which the ticket is valid. Combined with
endtime, specifies the life of the ticket. If absent from the ticket, its
value should be treated as that of the authtime field.
endtime Contains the time after which the ticket is no longer honored (its
expiration time). Individual services can place their own limits on the
life of a ticket and reject tickets that have not yet expired. As such, this
is really an upper bound on the expiration time for the ticket.
renew-till Indicates the maximum endtime that can be included in a renewal.
Present only in tickets that have the RENEWABLE flag set in the flags
Kerberos 573
field. Can be thought of as the absolute expiration time for the ticket,
including all renewals.
caddr Contains zero or more host addresses, which are the addresses from
which the ticket can be used. If no addresses, the ticket can be used
from any location. The Key Distribution Center’s decision to issue or
the end server’s decision to accept a zero-address ticket is a policy
decision left to the Kerberos and end-service administrators. They can
refuse to issue or accept such tickets.
The ticket includes network addresses to make it harder for an attacker
to use stolen credentials. Because the session key is not sent over the
network in cleartext, credentials can’t be stolen simply by listening to
the network. An attacker has to gain access to the session key (perhaps
through operating system security breaches or a careless user’s unattended
session) to successfully use stolen tickets.
authorization-data Serves to pass authorization data from the principal on whose behalf a
ticket was issued to the application service. Contains the names of
service-specific objects and the rights to those objects, specific to the
end service. If no authorization data is included, it is left out.
A principal can use this field to issue a proxy that is valid for a specific
purpose. A client who wants to print a file, for example, can obtain a
file server proxy to be passed to the print server. By specifying the
name of the file in the authorization-data field, the file server knows
that the print server can use only the client’s rights when accessing the
particular file to be printed.
The authorization-data field is optional and does not have to be
included in a ticket.
Authenticators
An authenticator is a record sent using a ticket to a server to certify the client’s knowledge of
the encryption key in the ticket, to help the server detect replays, and to help choose a “true
session key” to use with the particular session. The encoding is encrypted in the ticket’s session
key shared by the client and the server. An authenticator contains the following fields:
Authenticator = {
authenticator-vno[0] INTEGER,
crealm[1] Realm,
cname[2] Principal Name,
cksum[3] Checksum OPTIONAL,
Field Description
574 Part II: Gaining Access and Securing the Gateway
cusec[4] INTEGER,
ctime[5] KerberosTime,
subkey[6] EncryptionKey OPTIONAL,
seq-number[7] INTEGER OPTIONAL,
authorization-data[8] AuthorizationData OPTIONAL
}
Table 9.3 describes the fields in the authenticator.
Table 9.3
Authenticator Field Descriptions
Field Description
authenticator-vno Specifies the version number for the format of the authenticator.
crealm and cname Same as described for the ticket.
cksum Contains a checksum of the application data that accompanies the
KRB_AP_REQ.
cusec Contains the microsecond part of the client’s timestamp (its value
ranges from 0 to 999999). Often appears along with ctime, because the
two fields are used together to specify a reasonably accurate timestamp.
ctime Contains the current time on the client’s host.
subkey Contains the client’s choice for an encryption key to be used to protect
this specific application session. Unless an application specifies
otherwise, if this field is left out, the session key from the ticket is used.
seq-number Includes the initial sequence number to be used by the KRB_PRIV or
(optional) KRB_SAFE messages when sequence numbers are used to detect
replays. (It may also be used by application-specific messages.) When
included in the authenticator, this field specifies the initial sequence
number for messages from the client to the server. When included in
the AP-REP message, the initial sequence number is that for messages
from the server to the messages. Incremented by one after each message
is sent when used in KRB_PRIV or KRB_SAFE messages.
For sequence numbers to adequately support the detection of replays,
they should be nonrepeating, even across connection boundaries. The
initial sequence number should be random and uniformly distributed
across the full space of possible sequence numbers, so an attacker
cannot guess it and successive sequence numbers do not repeat other
sequences.
authorization-data Same as described for the ticket. Optional, and appears only when
additional restrictions are placed on the use of a ticket.
Kerberos 575
The Authentication Service Exchange
The Authentication Service (AS) exchange between the client and the Kerberos Authentication
Server is usually initiated by a client when it wants to obtain authentication credentials for a
given server but currently holds no credentials. The client’s secret key is used for encryption
and decryption. This exchange typically is used at the initiation of a login session to obtain
credentials for a Ticket Granting Server, which will subsequently be used to obtain credentials
for other servers without requiring further use of the client’s secret key. This exchange also is
used to request credentials for services that must not be mediated through the Ticket Granting
Service, but rather require a principal’s secret key, such as the password-changing service. A
password-changing request must not be honored unless the requester can provide the old
password (the user’s current secret key). Otherwise, it would be possible for someone to walk
up to an unattended session and change another user’s password. This exchange does not by
itself provide any assurance of the identity of the user.
To authenticate a user logging on to a local system, the credentials obtained in the Authentication
Server exchange can first be used in a Ticket Granting Server exchange to obtain credentials
for a local server. Those credentials must then be verified by the local server through
successful completion of the Client/Server exchange.
Note The exchange consists of two messages: KRB_AS_REQ from the client to Kerberos,
and KRB_AS_REP or KRB_ERROR in reply.
In the request, the client sends (in cleartext) its own identity and the identity of the server for
which it is requesting credentials. The response, KRB_AS_REP, contains a ticket for the client
to present to the server, and a session key to be shared by the client and the server. The session
key and additional information are encrypted in the client’s secret key.
The KRB_AS_REP message contains information that can be used to detect replays and
associate it with the message to which it replies. Various errors can occur, indicated by an error
response (KRB_ERROR) rather than the KRB_AS_REP response. The error message is not
encrypted. The KRB_ERROR message also contains information that can be used to associate
it with the message to which it replies. The lack of encryption in the KRB_ERROR message
precludes the capability to detect replays or fabrications of such messages.
Usually, the Authentication Server does not know whether the client truly is the principal
named in the request. It simply sends a reply without knowing or caring whether they are
the same—which is acceptable because nobody but the principal whose identity was given in
the request can use the reply. Its critical information is encrypted in that principal’s key. The
initial request supports an optional field that can be used to pass additional information that
might be needed for the initial exchange. This field can be used for preauthentication, but the
mechanism is not currently specified.
576 Part II: Gaining Access and Securing the Gateway
Generation of KRB_AS_REQ Message
The client can specify a number of options in the initial request. Among these options are the
following:
n Whether to perform preauthentication
n Whether the requested ticket is to be renewable, proxiable, or forwardable
n Whether the ticket should be postdated or permit postdating of derivative tickets, and
whether a renewable ticket can be accepted in lieu of a nonrenewable ticket if the
requested ticket expiration date cannot be satisfied by a nonrenewable ticket (due to
configuration constraints)
The client prepares the KRB_AS_REQ message and sends it to the Key Distribution Center.
Receipt of a KRB_AS_REQ Message
If all goes well, processing the KRB_AS_REQ message results in the creation of a ticket for the
client to present to the server.
Generation of a KRB_AS_REP Message
The authentication server looks up the client and server principals named in the
KRB_AS_REQ in its database, extracting their respective keys. If required, the server
preauthenticates the request, and if the preauthentication check fails, an error message with the
code KDC_ERR_PREAUTH_FAILED is returned. If the server cannot accommodate the
requested encryption type, an error message with code KDC_ERR_ETYPE_NOSUPP is
returned. Otherwise, it generates a random session key.
Random means that, among other things, guessing the next session key based on knowledge of
past session keys should be impossible. This can only be achieved in a pseudo-random number
generator if it is based on cryptographic principles. Using a truly random number generator,
such as one based on measurements of randomly physical phenomena, is preferred.
If the requested start time is absent or indicates a time in the past, then the start time of
the ticket is set to the authentication server’s current time. If it indicates a time in the
future, but the POSTDATED option has not been specified, then the error
KDC_ERR_CANNOT_POSTDATE is returned; otherwise, the requested start time is
checked against the policy of the local realm. The administrator might decide to prohibit
certain types or ranges of postdated tickets. If acceptable, the ticket’s start time is set as
requested and the INVALID flag is set in the new ticket. The postdated ticket must be
validated before use by presenting it to the Key Distribution Center after the start time has
been reached.
Kerberos 577
The expiration time of the ticket will be set to the minimum of the following:
n The expiration time (endtime) requested in the KRB_AS_REQ message
n The ticket’s start time plus the maximum allowable lifetime associated with the client
principal (the authentication server’s database includes a maximum ticket lifetime field
in each principal’s record)
n The ticket’s start time plus the maximum allowable lifetime associated with the server
principal
n The ticket’s start time plus the maximum lifetime set by the policy of the local realm
If the requested expiration time minus the start time (as determined above) is less than a sitedetermined
minimum lifetime, an error message with code KDC_ERR_NEVER_VALID is
returned. If the requested expiration time for the ticket exceeds what was determined as earlier,
and if the RENEWABLE-OK option was requested, then the RENEWABLE flag is set in the
new ticket, and the renew-till value is set as if the RENEWABLE option were requested. If the
RENEWABLE option has been requested or if the RENEWABLE-OK option has been set
and a renewable ticket is to be issued, then the renew-till field is set to the minimum of one of
the following:
n Its requested value
n The start time of the ticket plus the minimum of the two maximum renewable lifetimes
associated with the principals’ database entries
n The start time of the ticket plus the maximum renewable lifetime set by the policy of the
local realm
The flags field of the new ticket will have the following options set if they have been requested
and if the policy of the local realm permits: FORWARDABLE, MAY-POSTDATE, POSTDATED,
PROXIABLE, RENEWABLE. If the new ticket is postdated (the start time is in the
future), its INVALID flag also will be set.
If all of the preceding succeed, the server formats a KRB_AS_REP message. It copies the
addresses in the request into the caddr of the response, placing any required preauthentication
data into the padata of the response. Finally it uses the requested encryption method to
encrypt the ciphertext part in the client’s key and sends it to the client.
Receipt of a KRB_AS_REP Message
If the reply message type is KRB_AS_REP, then the client verifies that the cname and crealm
fields in the cleartext portion of the reply match what it requested. If any padata fields are
present, they can be used to derive the proper secret key to decrypt the message.
578 Part II: Gaining Access and Securing the Gateway
The client uses its secret key to decrypt the encrypted part of the response and verifies that the
nonce in the encrypted part matches the nonce it supplied in its request (to detect replays). It
also verifies that the sname and srealm in the response match those in the request, and that the
host address field also is correct. It then stores the ticket, session key, start and expiration
times, and other information for later use. The key-expiration field from the encrypted part
of the response can be checked to notify the user of impending key expiration. The client
program could then suggest remedial action, such as a password change.
Proper decryption of the KRB_AS_REP message is not sufficient to verify the identity of the
user. The user and an attacker could cooperate to generate a KRB_AS_REP format message
that decrypts properly but is not from the proper Key Distribution Center. If the host wants to
verify the identity of the user, it must require the user to present application credentials that
can be verified using a securely stored secret key. If those credentials can be verified, then the
identity of the user can be assured.
Generation of a KRB_ERROR Message
Several errors can occur, and the Authentication Server responds by returning an error
message, KRB_ERROR, to the client, with the error-code and e-text fields set to appropriate
values.
Receipt of a KRB_ERROR Message
If the reply message type is KRB_ERROR, then the client interprets it as an error and performs
whatever application-specific tasks are necessary to recover.
The Ticket Granting Service (TGS) Exchange
The Ticket Granting Service exchange between a client and the Kerberos Ticket Granting
Server is initiated by a client when it wants to obtain authentication credentials for a given
server. The server can be local or registered in a remote realm. It also is initiated when the
client wants to renew or validate an existing ticket or obtain a proxy ticket.
The client must already have acquired a ticket for the Ticket Granting Service using the
Authentication Server exchange. The Ticket Granting Ticket usually is obtained when a client
initially authenticates to the system, such as when a user logs in. The message format for the
Ticket Granting Service exchange is almost identical to that for the Authentication Server
exchange. The primary difference is that encryption and decryption in the Ticket Granting
Service exchange does not take place under the client’s key. Instead, the session key from the
Ticket Granting Ticket or renewable ticket, or subsession key from an Authenticator is used.
As with all application servers, expired tickets are not accepted by the Ticket Granting Service.
After a renewable or Ticket Granting Ticket expires, the client must use a separate exchange to
obtain valid tickets.
Kerberos 579
Note The exchange consists of two messages: KRB_TGS_REQ from the client to Kerberos,
and KRB_TGS_REP or KRB_ERROR in reply.
The KRB_TGS_REQ message includes information that authenticates the client, plus a
request for credentials. The authentication information consists of the authentication header
(KRB_AP_REQ), which includes the client’s previously obtained ticket-granting, renewable,
or invalid ticket. In the Ticket Granting Ticket and proxy cases, the request can include one or
more of the following:
n A list of network addresses
n A collection of typed authorization data to be sealed in the ticket for authorization use
by the application server, or additional tickets
The Ticket Granting Service reply (KRB_TGS_REP) contains the requested credentials,
encrypted in the session key from the Ticket Granting Ticket or renewable ticket, or if present,
in the subsession key from the Authenticator (part of the authentication header). The
KRB_ERROR message contains an error code and text that explains what went awry. The
KRB_ERROR message is not encrypted. The KRB_TGS_REP message contains information
that can be used to detect replays and associate it with the message to which it replies. The
KRB_ERROR message also contains information that can be used to associate it with the
message to which it replies. The lack of encryption in the KRB_ERROR message, however,
precludes the capability to detect replays or fabrications of such messages.
Generation of KRB_TGS_REQ Message
Before sending a request to the Ticket Granting Service, the client must determine in which
realm the application server is registered, using one of several ways:
n It might be known beforehand (because the realm is part of the principal identifier).
n It might be stored in a nameserver.
n The information can be obtained from a configuration file.
If the realm to be used is obtained from a nameserver that is not authenticated, the danger
of being spoofed becomes quite real. This might result in the use of a realm that has been
compromised, and would result in an attacker’s ability to compromise the authentication of
the application server to the client.
Note For more information on spoofing, see Chapter 6, “IP Spoofing and Sniffing.”
If the client does not already possess a Ticket Granting Ticket for the appropriate realm, then
one must be obtained. This is first attempted by requesting a Ticket Granting Ticket for the
580 Part II: Gaining Access and Securing the Gateway
destination realm from the local Kerberos server. The Kerberos server may return a Ticket
Granting Ticket for the desired realm.
Alternatively, the Kerberos server may return a Ticket Granting Ticket for a realm that is
further along the standard hierarchical path to the desired realm. In this case, the client must
repeat this step using a Kerberos server in the realm specified in the returned Ticket Granting
Ticket. If neither is returned, then the request must be retried using a Kerberos server for a
realm higher in the hierarchy. This request requires a Ticket Granting Ticket for the higher
realm that must be obtained by recursively applying these directions.
In the sample company, if a user in PROJECTX.RESEARCH.ABC.COM wants to use
services in PROJECTX.PAYROLL.ABC.COM, the software asks the local server at
PROJECTX.RESEARCH.ABC.COM for credentials. If they are not forthcoming directly the
server will return credentials for RESEARCH.ABC.COM. In turn, RESEARCH will return
credentials for ABC.COM, which will return credentials for PAYROLL.ABC.COM. Finally
he will get credentials for PROJECTX.RESEARCH.ABC.COM. Luckily for the user, this five
step process will all take place automatically.
After the client obtains a Ticket Granting Ticket for the appropriate realm, it determines
which Kerberos servers serve that realm and contacts one. The list could be obtained through a
configuration file or network service. As long as the secret keys exchanged by realms are kept
secret, only denial of service can result from a false Kerberos server.
As in the Authentication Server exchange, the client may specify a number of options in the
KRB_TGS_REQ message. The client prepares the KRB_TGS_REQ message, providing an
authentication header as an element of the padata field, and including the same fields as used
in the KRB_AS_REQ message along with several optional fields: the enc-authorization-data
field for application server use and additional tickets required by some options.
In preparing the authentication header, the client can select a subsession key under which the
response from the Kerberos server will be encrypted. If the client selects a subsession key, care
must be taken to ensure the randomness of the selected subsession key. If the subsession key is
not specified, the session key from the Ticket Granting Ticket is used. If the enc-authorization-
data is present, it must be encrypted in the subsession key, if present, from the authenticator
portion of the authentication header, or if not present, in the session key from the Ticket
Granting Ticket.
After the message is prepared, it is sent to a Kerberos server for the destination realm.
Receipt of a KRB_TGS_REQ Message
The KRB_TGS_REQ message is processed in a manner similar to the KRB_AS_REQ
message. However, there are many additional checks to be performed. The Kerberos server
must determine the server for which the accompanying ticket is destined and select the
appropriate key to decrypt it. Usually, it’s for the Ticket Granting Service and the Ticket
Kerberos 581
Granting Service’s key is used. If another realm issued the Ticket Granting Ticket, then the
appropriate inter-realm key must be used. If the accompanying ticket is for an application
server in the current realm, and the RENEW, VALIDATE, or PROXY options are specified in
the request, and the server for which a ticket is requested is the server named in the accompanying
ticket, then the Key Distribution Center uses the key of the application server to decrypt
the ticket in the authentication header. If no ticket can be found in the padata field, the
KDC_ERR_PADATA_TYPE_NOSUPP appears.
After the accompanying ticket has been decrypted, the user-supplied checksum in the
Authenticator must be verified against the contents of the request. The message is rejected
if the checksums do not match (with an error code of KRB_AP_ERR_MODIFIED) or if
the checksum is not keyed or not collision-proof (with an error code of
KRB_AP_ERR_INAPP_CKSUM). If the checksum type is not supported, the
KDC_ERR_SUMTYPE_NOSUPP error is returned. If the authorization-data are
present, they are decrypted using the subsession key from the Authenticator.
If any of the decryptions indicate failed integrity checks, the
KRB_AP_ERR_BAD_INTEGRITY error is returned.
Generation of a KRB_TGS_REP Message
The KRB_TGS_REP includes a ticket for the requested server. The Kerberos database is
queried to retrieve the record for the requested server, including the key with which the ticket
is to be encrypted. If the request is for a ticket granting ticket for a remote realm, and if no key
is shared with the requested realm, then the Kerberos server selects the realm closest to the
requested realm with which it does share a key, and uses that realm. This is the only case in
which the response from the Key Distribution Center is for a different server than that
requested by the client.
By default, the address field, the client’s name and realm, the list of transited realms, the
time of initial authentication, the expiration time, and the authorization data of the newly
issued ticket are copied from the Ticket Granting Ticket or renewable ticket. If the
transited field needs to be updated, but the transited type is not supported, the
KDC_ERR_TRTYPE_NOSUPP error is returned.
If the request specifies an end time, then the end time of the new ticket is set to the minimum
of the following:
n That request.
n The end time from the Ticket Granting Ticket.
n The start time of the Ticket Granting Ticket plus the minimum of the maximum life for
the application server and the maximum life for the local realm. The maximum life for
the requesting principal was already applied when the Ticket Granting Ticket was
issued.
582 Part II: Gaining Access and Securing the Gateway
If the new ticket is to be renewed, then the preceding end time is replaced by the minimum of
the following:
n The value of the renew_till field of the ticket
n The start time for the new ticket plus the life (end time-start time) of the old ticket
If the FORWARDED option has been requested, then the resulting ticket contains the
addresses specified by the client. This option is honored only if the FORWARDABLE flag is
set in the Ticket Granting Ticket. The PROXY option is similar. The resulting ticket contains
the addresses specified by the client. It is honored only if the PROXIABLE flag in the Ticket
Granting Ticket is set. The PROXY option is not honored on requests for additional Ticket
Granting Tickets.
If the requested start time is absent or indicates a time in the past, then the start time of the
ticket is set to the authentication server’s current time. If it indicates a time in the future, but
the POSTDATED option has not been specified or the MAY-POSTDATE flag is not set in
the Ticket Granting Ticket, then the error KDC_ERR_CANNOT_POSTDATE is returned.
Otherwise, if the Ticket Granting Ticket has the MAYPOSTDATE flag set, then the resulting
ticket will be postdated and the requested start time is checked against the policy of the local
realm. If acceptable, the ticket’s start time is set as requested, and the INVALID flag is set. The
postdated ticket must be validated before use by presenting it to the Key Distribution Center
after the start time has been reached. However, in no case may the start time, end time, or
renew-till time of a newly issued postdated ticket extend beyond the renew-till time of the
Ticket Granting Ticket.
If the ENC-TKT-IN-SKEY option has been specified and an additional ticket has been
included in the request, the Key Distribution Center will decrypt the additional ticket using
the key for the server to which the additional ticket was issued and verify that it is a Ticket
Granting Ticket. If the name of the requested server is missing from the request, the name of
the client in the additional ticket will be used. Otherwise the name of the requested server will
be compared to the name of the client in the additional ticket and if different, the request will
be rejected. If the request succeeds, the session key from the additional ticket will be used to
encrypt the new ticket that is issued instead of using the key of the server for which the new
ticket will be used. This enables easy implementation of user-to-user authentication, which
uses Ticket Granting Ticket session keys instead of secret server keys in situations where such
secret keys could be easily compromised.
If the RENEW option is requested, then the Key Distribution Center will verify that the
RENEWABLE flag is set in the ticket and that the renew_till time is still in the future. If the
VALIDATE option is requested, the Key Distribution Center will check that the start time has
passed and the INVALID flag is set. If the PROXY option is requested, then the Key Distribution
Center will check that the PROXIABLE flag is set in the ticket. If the tests succeed, the
Key Distribution Center will issue the appropriate new ticket.
Kerberos 583
Whenever a request is made to the Ticket Granting Server, the presented ticket(s) is checked
against a hot-list of tickets that have been canceled. This hot-list might be implemented by
storing a range of issue dates for “suspect tickets.” If a presented ticket had an authtime in that
range, it would be rejected. In this way, a stolen Ticket Granting Ticket or renewable ticket
cannot be used to gain additional tickets (renewals or otherwise) once the theft has been
reported. Any normal ticket obtained before it was reported stolen will still be valid, but only
until the normal expiration time.
The ciphertext part of the response in the KRB_TGS_REP message is encrypted in the subsession
key from the Authenticator, if present, or the session key from the Ticket Granting
Ticket. It is not encrypted using the client’s secret key. Furthermore, the client’s key’s expiration
date and the key version number fields are left out because these values are stored along
with the client’s database record, and that record is not needed to satisfy a request based on a
Ticket Granting Ticket.
Encoding the Transited Field
If the identity of the server in the Ticket Granting Ticket that is presented to the Key Distribution
Center as part of the authentication header is that of the Ticket Granting Service, but
the Ticket Granting Ticket was issued from another realm, the Key Distribution Center looks
up the inter-realm key shared with that realm and uses that key to decrypt the ticket. If the
ticket is valid, the Key Distribution Center honors the request, subject to the constraints
outlined earlier in the section describing the Authentication Server exchange.
The realm part of the client’s identity is taken from the Ticket Granting Ticket. The name of
the realm that issued the Ticket Granting Ticket is added to the transited field of the ticket to
be issued. This is accomplished by reading the transited field from the Ticket Granting Ticket,
adding the new realm to the set, then constructing and writing out its encoded (shorthand)
form. This may involve a rearrangement of the existing encoding.
The Ticket Granting Service does not add the name of its own realm. Instead, its responsibility
is to add the name of the previous realm. This prevents a malicious Kerberos server from
intentionally leaving out its own name. It could, however, omit other realms’ names.
The names of neither the local realm nor the principal’s realm are included in the transited
field. They appear elsewhere in the ticket and both are known to have taken part in authenticating
the principal. Because the endpoints are not included, both local and single-hop interrealm
authentication result in an empty transited field.
Because the name of each realm transited is added to this field, it can become very long. To
decrease the length of this field, its contents are encoded. The initially supported encoding is
optimized for the normal case of inter-realm communication, a hierarchical arrangement of
realms using domain or X.500 style realm names. This encoding is called DOMAIN-X500-
COMPRESS.
584 Part II: Gaining Access and Securing the Gateway
Receipt of a KRB_TGS_REP Message
After the client receives the KRB_TGS_REP, it processes it in the same manner as the
KRB_AS_REP processing described earlier. The primary difference is that the ciphertext part
of the response must be decrypted using the session key from the Ticket Granting Ticket
rather than the client’s secret key.
Specifications for the Authentication Server
and Ticket Granting Service Exchanges
This section specifies the format of the messages used in exchange between the client and the
Kerberos server.
Key Distribution Center Option Flags
Requests to the Key Distribution Center can be accompanied by a list of optional requests.
These options indicate the flags that the client wants set on the tickets, as well as other
information to modify the behavior of the Key Distribution Center. Options are specified
in a bit field, kdc_options.
Where appropriate, the name of an option may be the same as the flag set by that option.
Although usually the bit in the options field is the same as that in the flags field, this is not
guaranteed. Table 9.4 describes the Key Distribution Center options.
Table 9.4
Key Distribution Center Options
Bit(s) Name Description
0 RESERVED Reserved for future expansion.
1 FORWARDABLE The FORWARDABLE option indicates that the ticket to
be issued is to have its forwardable flag set.
2 FORWARDED The FORWARDED option is only specified in a request
to the Ticket Granting Server and will only be honored if
the Ticket Granting Ticket in the request has its
FORWARDABLE bit set. This option indicates that this
is a request for forwarding. The address(es) of the host
from which the resulting ticket is to be valid are included
in the addresses field of the request.
3 PROXIABLE The PROXIABLE option indicates that the ticket to be
issued is to have its proxiable flag set. It may only be set
on the initial request, or in a subsequent request if the
Ticket Granting Ticket on which it is based is also
proxiable.
Kerberos 585
4 PROXY The PROXY option indicates that this is a request for a
proxy. This option will only be honored if the Ticket
Granting Ticket in the request has its PROXIABLE bit
set. The address(es) of the host from which the resulting
ticket is to be valid are included in the addresses field of
the request.
5 ALLOW-POSTDATE The ALLOW-POSTDATE option indicates that the
ticket to be issued is to have its MAY-POSTDATE flag
set. It may only be set on the initial request, or if the
Ticket Granting Ticket on which it is based also has its
MAY-POSTDATE flag set.
6 POSTDATED The POSTDATED option indicates that this is a request
for a postdated ticket. This option will only be honored if
the Ticket Granting Ticket on which it is based has its
MAY-POSTDATE flag set. The resulting ticket will also
have its INVALID flag set, and that flag may be reset by a
subsequent request to the Key Distribution Center after
the start time in the ticket has been reached.
7 UNUSED This option is presently unused.
8 RENEWABLE The RENEWABLE option indicates that the ticket to be
issued is to have its RENEWABLE flag set. It may only
be set on the initial request, or when the Ticket Granting
Ticket on which the request is based is also renewable. If
this option is requested, then the rtime field in the request
contains the desired absolute expiration time for the
ticket.
9–26 RESERVED Reserved for future use.
27 RENEWABLE-OK The RENEWABLE-OK option indicates that a renewable
ticket will be acceptable if a ticket with the requested
life cannot otherwise be provided. If a ticket with the
requested life cannot be provided, then a renewable ticket
may be issued with a renew-till equal to the requested end
time. The value of the renew-till field may still be limited
by local limits, or limits selected by the individual
principal or server.
28 ENC-TKT-IN-SKEY This option is used only by the Ticket Granting Service.
The ENC-TKT-IN-SKEY option indicates that the ticket
Bit(s) Name Description
continues
586 Part II: Gaining Access and Securing the Gateway
for the end server is to be encrypted in the session key
from the additional Ticket Granting Ticket provided.
29 RESERVED Reserved for future use.
30 RENEW The RENEW option indicates that the present request is
for a renewal. This option will only be honored if the
ticket to be renewed has its RENEWABLE flag set and if
the time in its renew-till field has not passed. The ticket
to be renewed is passed in the padata field as part of the
authentication header.
31 VALIDATE This option is used only by the Ticket Granting Service.
The VALIDATE option indicates that the request is to
validate a postdated ticket. It will only be honored if the
ticket presented is postdated, presently has its INVALID
flag set, and would be otherwise usable at this time. A
ticket cannot be validated before its start time.
KRB_KDC_REQ Definition
The KRB_KDC_REQ message has no type of its own. Instead, its type is either
KRB_AS_REQ or KRB_TGS_REQ, depending on whether the request is for an initial ticket
or an additional ticket. In either case, the message is sent from the client to the Authentication
Server to request credentials for a service.
The message fields are as follows:
AS-REQ = KDC-REQ
TGS-REQ = KDC-REQ
KDC-REQ = {
pvno[1] INTEGER,
msg-type[2] INTEGER,
padata[3] SEQUENCE OF PA-DATA OPTIONAL,
req-body[4] KDC-REQ-BODY
}
PA-DATA = {
padata-type[1] INTEGER,
padata-value[2] BYTE STRING,
}
— might be encoded AP-REQ
Table 9.4, Continued
Key Distribution Center Options
Bit(s) Name Description
Kerberos 587
padata-type = PA-ENC-TIMESTAMP
padata-value = EncryptedData — PA-ENC-TS-ENC
PA-ENC-TS-ENC = {
patimestamp[0] KerberosTime, — client’s time
pausec[1] INTEGER OPTIONAL
}
KDC-REQ-BODY = {
kdc-options[0] KDCOptions,
cname[1] PrincipalName OPTIONAL,
— Used only in AS-REQ
realm[2] Realm, — Server’s realm
— Also client’s in AS-REQ
sname[3] PrincipalName OPTIONAL,
from[4] KerberosTime OPTIONAL,
till[5] KerberosTime,
rtime[6] KerberosTime OPTIONAL,
nonce[7] INTEGER,
etype[8] SEQUENCE OF INTEGER, — EncryptionType,
— in preference order
addresses[9] HostAddresses OPTIONAL,
enc-authorization-data[10] EncryptedData OPTIONAL,
— Encrypted AuthorizationData encoding
additional-tickets[11] SEQUENCE OF Ticket OPTIONAL
The fields in this message are described in table 9.5.
Table 9.5
KRB_KDC_REQ Message Fields
Field Description
pvno Specifies the protocol version number of each message.
msg-type Indicates the type of protocol message. Almost always the same as
the application identifier associated with a message. Included to
make the identifier more readily accessible to the application. For
the KDC-REQ message, is KRB_AS_REQ or KRB_TGS_REQ.
padata Contains authentication information that may be needed before
credentials can be issued or decrypted. In the case of requests for
additional tickets (KRB_TGS_REQ), this field includes an
element that has padata-type of PA-TGS-REQ and data of an
authentication header (Ticket Granting Ticket and authenticator).
The checksum in the authenticator (which must be collisionproof)
is to be computed over the KDC-REQ-BODY encoding.
continues
588 Part II: Gaining Access and Securing the Gateway
In most requests for initial authentication and most replies, the
padata field is left out.
Also can contain information needed by certain extensions to the
Kerberos protocol. It might be used, for example, to initially verify
the identity of a client before any response is returned.
patimestamp Contains the client’s time.
pausec Contains the microseconds. It may be omitted if a client cannot
generate more than one request per second.
Also contains information needed to help the KDC or the client
select the key needed for generating or decrypting the response,
useful for supporting the use of certain “smartcards” with
Kerberos.
padata-type Indicates the way that the padata-value element is to be interpreted.
Negative values of padata-type are reserved for unregistered
use. Non-negative values are used for a registered interpretation of
the element type.
req-body Delimits the extent of the remaining fields. If a checksum is to be
calculated over the request, it is calculated over an encoding of the
KDC-REQ-BODY sequence that is enclosed within the req-body
field.
kdc-options Appears in the KRB_AS_REQ and KRB_TGS_REQ requests to
the Key Distribution Center. Indicates the flags that the client
wants set on the tickets as well as other information to modify the
behavior of the Key Distribution Center.
cname and sname Same as those described for the ticket. sname may only be absent
when the ENC-TKT-IN-SKEY option is specified. If absent, the
name of the server is taken from the name of the client in the
ticket passed as additional-tickets.
enc-authorization-data The enc-authorization-data, if present (and it can only be present
in the TGS_REQ form), is an encoding of the desired
authorization-data. It is encrypted under the sub-session key if
present in the Authenticator, or alternatively from the session key
in the Ticket Granting Ticket, both from the padata field in the
KRB_AP_REQ.
Table 9.5, Continued
KRB_KDC_REQ Message Fields
Field Description
Kerberos 589
realm Specifies the realm part of the server’s principal identifier. In the
Authentication Server exchange, this is also the realm part of the
client’s principal identifier.
from Included in the KRB_AS_REQ and KRB_TGS_REQ ticket
requests when the requested ticket is to be postdated and specifies
the desired start time for the requested ticket.
till Contains the expiration date requested by the client in a ticket
request.
rtime (optional) The requested renew-till time sent from a client to the Key
Distribution Center in a ticket request.
nonce Part of the Key Distribution Center request and response. Holds a
random number generated by the client. If the same number is
included in the encrypted response from the Key Distribution
Center, it provides evidence that the response is fresh and has not
been replayed by an attacker. Nonces must never be reused.
Ideally it should be generated randomly, but if the correct time is
known, it may suffice. If the time is used as the nonce, and the
time is ever reset backward, there is a small, but finite, probability
that a nonce will be reused.
etype Specifies the desired encryption algorithm to be used in the
response.
addresses Included in the initial request for tickets, and optionally included
in requests for additional tickets from the Ticket Granting Service;
specifies the addresses from which the requested ticket is to be
valid. Usually includes the addresses for the client’s host. If a proxy
is requested, contains other addresses. The contents of this field
are usually copied by the Key Distribution Center into the caddr
field of the resulting ticket.
additional-tickets Additional tickets may be optionally included in a request to the
Ticket Granting Service. If the ENC-TKT-IN-SKEY option has
been specified, then the session key from the additional ticket will
be used in place of the server’s key to encrypt the new ticket. If
more than one option which requires additional tickets has been
specified, then the additional tickets are used in the order specified
by the ordering of the options bits (see kdc-options, earlier).
The optional fields are included only if necessary to perform the operation specified in the kdcoptions
field.
Field Description
590 Part II: Gaining Access and Securing the Gateway
In KRB_TGS_REQ, the protocol version number appears twice and two different message
types appear. The KRB_TGS_REQ message contains these fields, as does the authentication
header (KRB_AP_REQ) passed in the padata field.
KRB_KDC_REP Definition
The KRB_KDC_REP message format is used for the reply from the Key Distribution Center
for an initial (Authentication Server) request or a subsequent (Ticket Granting Service)
request. The message type is KRB_AS_REP or KRB_TGS_REP.
The key used to encrypt the ciphertext part of the reply depends on the message type. For
KRB_AS_REP, the ciphertext is encrypted in the client’s secret key, and the client’s key
version number is included in the key version number for the encrypted data. For
KRB_TGS_REP, the ciphertext is encrypted in the subsession key from the Authenticator,
or if absent, the session key from the Ticket Granting Ticket used in the request. In that case,
no version number is present in the EncryptedData sequence.
The KRB_KDC_REP message contains the following fields:
AS-REP = KDC-REP
TGS-REP = KDC-REP
KDC-REP = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
padata[2] SEQUENCE OF PA-DATA OPTIONAL,
crealm[3] Realm,
cname[4] PrincipalName,
ticket[5] Ticket,
enc-part[6] EncryptedData
}
EncASRepPart = EncKDCRepPart
EncTGSRepPart = EncKDCRepPart
EncKDCRepPart = {
key[0] EncryptionKey,
last-req[1] LastReq,
nonce[2] INTEGER,
key-expiration[3] KerberosTime OPTIONAL,
flags[4] TicketFlags,
authtime[5] KerberosTime,
starttime[6] KerberosTime OPTIONAL,
endtime[7] KerberosTime,
renew-till[8] KerberosTime OPTIONAL,
srealm[9] Realm,
sname[10] PrincipalName,
caddr[11] HostAddresses OPTIONAL
}
Kerberos 591
Table 9.6 describes the fields in this message.
Table 9.6
KRB_KDC_REP Message Fields
Field Description
pvno and msg-type Described earlier. msg-type is KRB_AS_REP or KRB_TGS_REP.
padata Described in detail earlier.
crealm, cname, Same as those described for the ticket.
srealm, and sname
ticket The newly issued ticket.
enc-part Serves as placeholder for the ciphertext and related information that
forms the encrypted part of a message.
key Same as described for the ticket.
last-req Returned by the Key Distribution Center and specifies the time(s) of
the last request by a principal. Depending on what information is
available, this might be the last time that a request for a Ticket
Granting Ticket was made, or the last time that a request based on a
Ticket Granting Ticket was successful. It might cover all servers for a
realm, or just the particular server. Some implementations may display
this information to the user to aid in discovering unauthorized use of
one’s identity. It is similar in spirit to the last login time displayed
when logging into timesharing systems.
nonce Described earlier.
key-expiration Part of the response from the Key Distribution Center and specifies
the time that the client’s secret key is due to expire.
flags, authtime, All duplicates of those found in the encrypted portion of the attached
starttime, endtime, ticket.
renew-till, and caddr
The Client/Server Authentication Exchange
Network applications use the client/server authentication (CS) exchange to authenticate the
client to the server and vice versa. The client must already have acquired credentials for the
server using the Authentication Server or Ticket Granting Server exchange.
592 Part II: Gaining Access and Securing the Gateway
Note The exchange consists of two messages: KRB_AP_REQ from the client to Kerberos,
and KRB_AP_REP or KRB_ERROR in reply.
The KRB_AP_REQ Message
The KRB_AP_REQ contains authentication information that should be part of the first
message in an authenticated transaction. It contains a ticket, an authenticator, and some
additional bookkeeping information. The ticket by itself is insufficient to authenticate a client,
because tickets are passed across the network in cleartext. Tickets contain an encrypted and an
unencrypted portion, so cleartext here refers to the entire unit. Tickets can be copied from one
message and replayed in another without any cryptographic skill. The Authenticator is used to
prevent invalid replay of tickets by proving to the server that the client knows the session key
of the ticket and thus is entitled to use it. The KRB_AP_REQ message is referred to elsewhere
as the “authentication header.”
Generation of a KRB_AP_REQ Message
When a client wants to initiate authentication to a server, it obtains a ticket and session key for
the desired service. The client can reuse any tickets it holds until they expire. The client then
constructs a new Authenticator from the system time, its name, optionally, an applicationspecific
checksum, an initial sequence number to be used in KRB_SAFE or KRB_PRIV
messages, and/or a session subkey to be used in negotiations for a session key unique to this
particular session.
Authenticators may not be reused and are rejected if replayed to a server. This can make
applications based on unreliable transports, such as UDP, difficult to code correctly. In such
cases, a new Authenticator must be generated for each retry. If a sequence number is to be
included, it should be chosen randomly so that even after many messages have been exchanged,
collision with other sequence numbers in use is not likely.
The client can indicate a requirement of mutual authentication or the use of a session-key
based ticket by setting the appropriate flag(s) in the ap-options field of the message.
The Authenticator is encrypted in the session key and combined with the ticket to form
the KRB_AP_REQ message that is then sent to the end server along with any additional
application-specific information.
Receipt of a KRB_AP_REQ Message
Authentication is based on the server’s current time of day (clocks must be loosely synchronized),
the Authenticator, and the ticket. If an error occurs, the server is expected to reply to
the client with a KRB_ERROR message. This message can be encapsulated in the application
protocol if its “raw” form is not acceptable to the protocol.
Kerberos 593
There are several checks the server makes to verify the authentication. If the message type is
not KRB_AP_REQ, the server returns the KRB_AP_ERR_MSG_TYPE error. If the key
version indicated by the ticket in the KRB_AP_REQ is not one the server can use, the
KRB_AP_ERR_BADKEYVER error is returned. If the USE-SESSION-KEY flag is set in the
ap-options field, it indicates to the server that the ticket is encrypted in the session key from
the server’s Ticket Granting Ticket rather than its secret key. Because it is possible for the
server to be registered in multiple realms, with different keys in each, the srealm field in the
unencrypted portion of the ticket in the KRB_AP_REQ is used to specify which secret key the
server should use to decrypt that ticket. The KRB_AP_ERR_NOKEY error code is returned if
the server doesn’t have the proper key to decipher the ticket.
The ticket is decrypted using the version of the server’s key specified by the ticket.
If the decryption routines detect a modification of the ticket, the
KRB_AP_ERR_BAD_INTEGRITY error is returned. In this case, chances are
good that different keys were used to encrypt and decrypt.
The authenticator is decrypted using the session key extracted from the decrypted ticket. If
decryption shows it to have been modified, the KRB_AP_ERR_BAD_INTEGRITY error is
returned. The name and realm of the client from the ticket are compared against the same
fields in the Authenticator.
If, on the other hand, they don’t match, the KRB_AP_ERR_BADMATCH error is returned.
They might not match, for example, if the wrong session key was used to encrypt the Authenticator.
The addresses in the ticket (if any) are then searched for an address that matches the
operating–system-reported address of the client. If no match is found or the server insists on
ticket addresses when none are present in the ticket, the KRB_AP_ERR_BADADDR error is
returned.
If the server time and the client time in the authenticator differ by more than the allowable
clock skew (5 minutes), the KRB_AP_ERR_SKEW error is returned. If the server name along
with the client name, time and microsecond fields from the Authenticator match any recently
seen such tuples, the KRB_AP_ERR_REPEAT error is returned.
The rejection here is restricted to Authenticators from the same principal to the same server.
Other client principals communicating with the same server principal should not have their
Authenticators rejected if the time and microsecond fields happen to match some other client’s
authenticator.
The server must remember any authenticator presented within the allowable clock skew, so
that a replay attempt is guaranteed to fail. If a server loses track of any authenticator presented
within the allowable clock skew, it will reject all requests until the clock skew interval has
passed. This assures that any lost or replayed authenticators will fall outside the allowable clock
skew and can no longer be successfully replayed. If this is not done, an attacker could conceivably
record the ticket and authenticator sent over the network to a server.
594 Part II: Gaining Access and Securing the Gateway
It could then disable the client’s host, pose as the disabled host, and replay the ticket and
authenticator to subvert the authentication. If a sequence number is provided in the authenticator,
the server saves it for later use in processing KRB_SAFE and/or KRB_PRIV messages. If
a subkey is present the server saves it for later use or uses it to help generate its own choice for a
subkey to be returned in a KRB_AP_REP message.
The server computes the age of the ticket: server time minus the start time inside the Ticket. If
the start time is later than the current time by more than the allowable clock skew or if the
INVALID flag is set in the ticket, the KRB_AP_ERR_TKT_NYV error is returned. Otherwise,
if the current time is later than the end time by more than the allowable clock skew, the
KRB_AP_ERR_TKT_EXPIRED error is returned.
If all these checks succeed without an error, the server is assured that the client possesses the
credentials of the principal named in the ticket and thus, the client has been authenticated to
the server.
Generation of a KRB_AP_REP Message
Typically, a client’s request includes both the authentication information and its initial request
in the same message. The server need not explicitly reply to the KRB_AP_REQ. If mutual
authentication is being performed, however, the KRB_AP_REQ message will have MUTUALREQUIRED
set in its ap-options field. Then a KRB_AP_REP message is required in response.
As with the error message, this message can be encapsulated in the application protocol if its
raw form is unacceptable to the application’s protocol. The timestamp and microsecond field
used in the reply must be the client’s timestamp and microsecond field, as provided in the
Authenticator. If a sequence number is to be included, it should be chosen randomly, as
described earlier for the Authenticator. A subkey can be included if the server desires to
negotiate a different subkey. The KRB_AP_REP message is encrypted in the session key
extracted from the ticket.
Receipt of a KRB_AP_REP Message
If a KRB_AP_REP message is returned, the client uses the session key from the credentials
obtained for the server to decrypt the message, and then verifies that the timestamp and
microsecond fields match those in the Authenticator it sent to the server. If they match, the
client is assured that the server is genuine. The sequence number and subkey, if present, are
retained for later use.
Using the Encryption Key
After the KRB_AP_REQ/KRB_AP_REP exchange has occurred, the client and server share
an encryption key that can be used by the application. The “true session key” to be used for
KRB_PRIV, KRB_SAFE, or other application-specific purposes can be chosen by the application
based on the subkeys in the KRB_AP_REP message and the Authenticator. In some cases,
Kerberos 595
the use of this session key is implicit in the protocol. In other cases the method of use must be
chosen from several alternatives.
With both the one-way and mutual authentication exchanges, the peers should take care not to
send sensitive information to each other without proper assurances. In particular, applications
that require privacy or integrity should use the KRB_AP_REP or KRB_ERROR responses
from the server to client to assure both client and server of their peer’s identity. If an application
protocol requires privacy of its messages, it can use the KRB_PRIV message. The
KRB_SAFE message can be used to assure integrity.
Client/Server (CS) Message Specifications
This section specifies the format of the messages used for the authentication of the client to the
application server.
KRB_AP_REQ Definition
The KRB_AP_REQ message contains the Kerberos protocol version number, the message type
KRB_AP_REQ, an options field to indicate any options in use, and the ticket and authenticator
themselves. The KRB_AP_REQ message is often referred to as the authentication header.
AP-REQ = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
ap-options[2] APOptions,
ticket[3] Ticket,
authenticator[4] EncryptedData
}
APOptions = BIT STRING {
reserved(0),
use-session-key(1),
mutual-required(2),
reserved(3-31)
}
Table 9.7 describes the fields in this message.
Table 9.7
KRB_AP_REQ Message Fields
Field Description
pvno and msg-type Described earlier. msg-type is KRB_AP_REQ.
ap-options Appears in the application request (KRB_AP_REQ) and affects the
way the request is processed.
continues
596 Part II: Gaining Access and Securing the Gateway
Table 9.7, Continued
KRB_AP_REQ Message Fields
Field Description
The USE-SESSION-KEY option indicates that the ticket the client
is presenting to a server is encrypted in the session key from the
server’s Ticket Granting Ticket. When this option is not specified,
the ticket is encrypted in the server’s secret key.
The MUTUAL-REQUIRED option tells the server that the client
requires mutual authentication, and that it must respond with a
KRB_AP_REP message.
ticket Authenticates the client to the server.
authenticator Contains the authenticator, which includes the client’s choice of a
subkey.
KRB_AP_REP Definition
The KRB_AP_REP message contains the Kerberos protocol version number, the message type,
and an encrypted timestamp. The message is sent in response to an application request
(KRB_AP_REQ) in which the mutual authentication option has been selected in the apoptions
field.
AP-REP = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
enc-part[2] EncryptedData
}
EncAPRepPart = {
ctime[0] KerberosTime,
cusec[1] INTEGER,
subkey[2] EncryptionKey OPTIONAL,
seq-number[3] INTEGER OPTIONAL
}
Table 9.8 describes the fields in this message.
Table 9.8
KRB_AP_REP Message Fields
Field Description
pvno and msg-typeq Described earlier. msg-type is KRB_AP_REP.
enc-part Described earlier.
Kerberos 597
Field Description
ctime Contains the current time on the client’s host.
cusec Contains the microsecond part of the client’s timestamp.
subkey Contains an encryption key to be used to protect this specific
application session. Unless an application specifies otherwise, if this
field is left out, the subsession key from the authenticator is used. If
the subsession key also is left out, the session key from the ticket is
used.
Error Message Reply
If an error occurs while processing the application request, the KRB_ERROR message is sent
in response. The cname and crealm fields can be left out if the server cannot determine their
appropriate values from the corresponding KRB_AP_REQ message. If the Authenticator was
decipherable, the ctime and cusec fields contain the values from it.
The KRB_SAFE Exchange
The KRB_SAFE message may be used by clients that require the capability to detect modifications
of messages they exchange. It achieves this by including a keyed, collision-proof
checksum of the user data and some control information. The checksum is keyed with an
encryption key. Kerberos usually uses the last key negotiated via subkeys, or the session key if
no negotiation has occurred.
Generation of a KRB_SAFE Message
When an application needs to send a KRB_SAFE message, it collects its data and the appropriate
control information and computes a checksum over them. The checksum algorithm should
be some sort of keyed one-way function such as the RSA-MD5-DES, or the DES-MAC,
generated using the subsession key if present, or otherwise the session key. Different algorithms
can be selected by changing the checksum type in the message. Unkeyed or non-collision-proof
checksums are not suitable for this use.
Next, a decision must be made about the appropriate control information to use. The control
information for the KRB_SAFE message includes a timestamp and a sequence number.
Designers of applications that use the KRB_SAFE message must choose at least one of the two
mechanisms based on the needs of the application protocol.
Sequence numbers are useful when all messages sent will be received by one’s peer. Connection
state presently is required to maintain the session key, so maintaining the next sequence
number should not present an additional problem.
598 Part II: Gaining Access and Securing the Gateway
If the application protocol is expected to tolerate lost messages without them being resent, the
use of the timestamp is the appropriate replay detection mechanism. Using timestamps also is
the appropriate mechanism for multicast protocols in which all one’s peers share a common
subsession key, but some messages are sent to a subset of one’s peers.
After computing the checksum, the client then transmits the information and checksum to the
recipient.
Receipt of KRB_SAFE Message
When an application receives a KRB_SAFE message, it verifies it as follows. If any error
occurs, an error code is reported for use by the application.
The message is first checked by verifying that the protocol version and type fields
match the current version and KRB_SAFE, respectively. A mismatch generates a
KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error.
The application verifies that the checksum used is a collision-proof keyed checksum, and if it
is not, a KRB_AP_ERR_INAPP_CKSUM error is generated. The recipient verifies that the
operating system’s report of the sender’s address matches the sender’s address in the message. If
a recipient address is specified or the recipient requires an address, then it checks that one of
the recipient’s addresses appears as the recipient’s address in the message. A failed match for
either case generates a KRB_AP_ERR_BADADDR error. Then the timestamp and usec
and/or the sequence number fields are checked.
If timestamp and usec are expected and not present, or they are present but not current, the
KRB_AP_ERR_SKEW error is generated. If the server name along with the client name, time,
and microsecond fields from the Authenticator match any recently seen such tuples, the
KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included, or
a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error is
generated. If neither a timestamp and usec nor a sequence number is present, a
KRB_AP_ERR_MODIFIED error is generated.
Finally, the checksum is computed over the data and control information, and if it doesn’t
match the received checksum, a KRB_AP_ERR_MODIFIED error is generated.
If all the checks succeed, the application is assured that the message was generated by its peer
and not modified in transit.
KRB_SAFE Message Specification
This section specifies the format of a message that can be used by either side, client or server,
of an application to send a tamperproof message to its peer. It presumes that a session key
has previously been exchanged; for example, by using the KRB_AP_REQ/KRB_AP_REP
messages.
Kerberos 599
KRB_SAFE Definition
The KRB_SAFE message contains user data along with a collision-proof checksum keyed with
the session key. The message fields are as follows:
KRB-SAFE = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
safe-body[2] KRB-SAFE-BODY,
cksum[3] Checksum
}
KRB-SAFE-BODY = {
user-data[0] BYTE STRING,
timestamp[1] KerberosTime OPTIONAL,
usec[2] INTEGER OPTIONAL,
seq-number[3] INTEGER OPTIONAL,
s-address[4] HostAddress,
r-address[5] HostAddress OPTIONAL
}
The fields for this message are described in table 9.9.
Table 9.9
KRB_SAFE Message Fields
Field Description
pvno and msg-type Described earlier. msg-type is KRB_SAFE.
safe-body Serves as a placeholder for the body of the KRB-SAFE message. It is to
be encoded separately and then have the checksum computed over it,
for use in the cksum field.
cksum Contains the checksum of the application data. The checksum is
computed over the encoding of the KRB-SAFE-BODY sequence.
user-data Part of the KRB_SAFE and KRB_PRIV messages. It contains the
application specific data that is being passed from the sender to the
recipient.
timestamp Part of the KRB_SAFE and KRB_PRIV messages. Its contents are the
current time as known by the sender of the message. By checking the
timestamp, the recipient of the message is able to make sure that it was
recently generated, and is not a replay.
usec Part of the KRB_SAFE and KRB_PRIV headers. It contains the
microsecond part of the timestamp.
seq-number Described earlier.
continues
600 Part II: Gaining Access and Securing the Gateway
s-address Specifies the address in use by the sender of the message.
r-address Specifies the address in use by the recipient of the message. It can be
omitted for some uses, such as broadcast protocols, but the recipient
can arbitrarily reject such messages. This field, along with s-address,
can be used to help detect messages that have been incorrectly or
maliciously delivered to the wrong recipient.
The KRB_PRIV Exchange
The KRB_PRIV message provides clients confidentiality and the capability to detect modifications
of exchanged messages by encrypting the messages and adding control information.
Generation of a KRB_PRIV Message
When an application needs to send a KRB_PRIV message, it collects its data and the appropriate
control information and encrypts them under an encryption key, usually the last key
negotiated via subkeys, or if no negotiation has occurred, the session key. As part of the control
information, the client must choose to use a timestamp, a sequence number, or both. After the
user data and control information are encrypted, the client transmits the ciphertext and some
“envelope” information to the recipient.
Receipt of KRB_PRIV Message
When an application receives a KRB_PRIV message, it verifies it as follows. If any error
occurs, an error code is reported for use by the application.
The message is first checked by verifying that the protocol version and type fields
match the current version and KRB_PRIV, respectively. A mismatch generates a
KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application then
decrypts the ciphertext and processes the resultant plaintext. If decryption shows the data to
have been modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated. The recipient
verifies that the operating system’s report of the sender’s address matches the sender’s address
in the message. If a recipient address is specified or the recipient requires an address, then it
checks that one of the recipient’s addresses appears as the recipient’s address in the message. A
failed match for either case generates a KRB_AP_ERR_BADADDR error.
Then the timestamp and usec and/or the sequence number fields are checked. If timestamp
and usec are expected and not present, or if they are present but not current, the
KRB_AP_ERR_SKEW error is generated. If the server name along with the client name, time,
Table 9.9, Continued
KRB_SAFE Message Fields
Field Description
Kerberos 601
and microsecond fields from the Authenticator match any recently seen such tuples, the
KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included,
or a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error
is generated. If neither a timestamp and usec nor a sequence number is present, a
KRB_AP_ERR_MODIFIED error is generated.
If all the checks succeed, the application can assume the message was generated by its peer, and
was securely transmitted.
KRB_PRIV Message Specification
This section specifies the format of a message that can be used by either side, client or server,
of an application to send, securely and privately, a message to its peer. It presumes that a
session key has previously been exchanged.
KRB_PRIV Definition
The KRB_PRIV message contains user data encrypted in the Session Key. The message fields
are as follows:
KRB-PRIV = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
enc-part[3] EncryptedData
}
EncKrbPrivPart = {
user-data[0] BYTE STRING,
timestamp[1] KerberosTime OPTIONAL,
usec[2] INTEGER OPTIONAL,
seq-number[3] INTEGER OPTIONAL,
s-address[4] HostAddress, — sender’s addr
r-address[5] HostAddress OPTIONAL
— recip’s addr
}
Table 9.10 describes the fields for this message.
Table 9.10
KRB_PRIV Message Fields
Field Description
pvno and msg-type Described earlier. msg-type is KRB_PRIV.
enc-part Holds an encoding of the EncKrbPrivPart sequence encrypted under
the session key. This encrypted encoding is used for the enc-part field
of the KRB-PRIV message.
continues
602 Part II: Gaining Access and Securing the Gateway
user-data, Described earlier.
timestamp, usec,
s-address, and
r-address
seq-number Described earlier.
The KRB_CRED Exchange
The KRB_CRED message can be used by clients who require the capability to send Kerberos
credentials from one host to another. It achieves this by sending the tickets together with
encrypted data that contain the session keys and other information associated with the tickets.
Generation of a KRB_CRED Message
When an application needs to send a KRB_CRED message, it first obtains credentials to be
sent to the remote host. Then it uses the ticket or tickets it obtains to construct a KRB_CRED
message. It places the necessary session key to use each ticket in the key field of the corresponding
KrbCredInfo sequence of the encrypted part of the KRB_CRED message.
Other information associated with each ticket and obtained during the KRB_TGS exchange
also is placed in the corresponding KrbCredInfo sequence in the encrypted part of the
KRB_CRED message. The current time and, if specifically required by the application, the
nonce, s-address, and r-address fields are placed in the encrypted part of the KRB_CRED
message. It is then encrypted under an encryption key previously exchanged in the KRB_AP
exchange.
Receipt of KRB_CRED Message
When an application receives a KRB_CRED message, it verifies it. If any error occurs, an error
code is reported for use by the application. The message is verified by checking that the
protocol version and type fields match the current version and KRB_CRED, respectively. A
mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error.
The application then decrypts the ciphertext and processes the resultant plaintext. If
decryption shows the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY error
is generated. If present or required, the recipient verifies that the operating system’s report of
the sender’s address matches the sender’s address in the message.
Next it checks that one of the recipient’s addresses appears as the recipient’s address in the
message. A failed match for either case generates a KRB_AP_ERR_BADADDR error. The
Table 9.10, Continued
KRB_PRIV Message Fields
Field Description
Kerberos 603
timestamp and usec fields, and the nonce field if required, are checked next. If the timestamp
and usec are not present, or if they are present but not current, the KRB_AP_ERR_SKEW
error is generated.
If all the checks succeed, the application stores each of the new tickets in its ticket cache
together with the session key and other information in the corresponding KrbCredInfo
sequence from the encrypted part of the KRB_CRED message.
KRB_CRED Message Specification
This section specifies the format of a message that can be used to send Kerberos credentials
from one principal to another. It presumes that a session key has already been exchanged
perhaps by using the KRB_AP_REQ/KRB_AP_REP messages.
KRB_CRED Definition
The KRB_CRED message contains a sequence of tickets to be sent and information needed to
use the tickets, including the session key from each. The information needed to use the tickets
is encrypted under an encryption key previously exchanged. The message fields are as follows:
KRB-CRED = {
pvno[0] INTEGER,
msg-type[1] INTEGER, — KRB_CRED
tickets[2] SEQUENCE OF Ticket,
enc-part[3] EncryptedData
}
EncKrbCredPart = {
ticket-info[0] SEQUENCE OF KrbCredInfo,
nonce[1] INTEGER OPTIONAL,
timestamp[2] KerberosTime OPTIONAL,
usec[3] INTEGER OPTIONAL,
s-address[4] HostAddress OPTIONAL,
r-address[5] HostAddress OPTIONAL
}
KrbCredInfo = {
key[0] EncryptionKey,
prealm[1] Realm OPTIONAL,
pname[2] PrincipalName OPTIONAL,
flags[3] TicketFlags OPTIONAL,
authtime[4] KerberosTime OPTIONAL,
starttime[5] KerberosTime OPTIONAL,
endtime[6] KerberosTime OPTIONAL
renew-till[7] KerberosTime OPTIONAL,
srealm[8] Realm OPTIONAL,
sname[9] PrincipalName OPTIONAL,
caddr[10] HostAddresses OPTIONAL
}
604 Part II: Gaining Access and Securing the Gateway
Table 9.11 describes the fields in this message.
Table 9.11
KRB_CRED Message Fields
Field Description
pvno and msg-type Described earlier. msg-type is KRB_CRED.
tickets The tickets obtained from the Key Distribution Center specifically
for use by the intended recipient. Successive tickets are paired with
the corresponding KrbCredInfo sequence from the enc-part of the
KRB-CRED message.
enc-part Holds an encoding of the EncKrbCredPart sequence encrypted
under the session key shared between the sender and the intended
recipient. This encrypted encoding is used for the enc-part field of
the KRB-CRED message.
nonce If practical, an application may require the inclusion of a nonce
generated by the recipient of the message. If the same value is
included as the nonce in the message, it provides evidence that the
message is fresh and has not been replayed by an attacker. A nonce
must never be reused.
timestamp and usec Specify the time that the KRB-CRED message was generated. The
time is used to provide assurance that the message is fresh.
s-address and r-address Described earlier. Used to provide additional assurance of the
integrity of the KRB-CRED message.
key Exists in the corresponding ticket passed by the KRB-CRED
message and is used to pass the session key from the sender to the
intended recipient.
The following fields are optional. If present, they can be associated with the credentials in the
remote ticket file. If left out, it is assumed that the recipient of the credentials already knows
their value.
Field Description
prealm and pname The name and realm of the delegated principal identity.
lags, authtime, starttime, Contain the values of the corresponding fields from the
endtime, renew-till, ticket found in the ticket field. Descriptions of sname, and
srealm, sname, and caddr the fields are identical to the descriptions in the
caddr KDC-REP message.
Kerberos 605
Names
Kerberos realms are encoded as GeneralString. Realms cannot contain a character that has the
code 0 (the ASCII NULL). Most realms consist of several components separated by periods (.)
in the style of Internet domain names or separated by slashes (/) in the style of X.500 names. A
PrincipalName is a sequence of components consisting of the following subfields:
Realm = GeneralString
PrincipalName = {
name-type[0] INTEGER,
name-string[1] GeneralString
}
The principal name encoding consists of the following two fields:
n name-type. Specifies the type of name that follows.
n name-string. Encodes a sequence of components that form a name. Each component
is encoded as a GeneralString. Taken together, a PrincipalName and a Realm form a
principal identifier. Most PrincipalNames will have only a few components, typically
one or two. No two names can be the same. At least one of the components, or the
realm, must be different.
Time
The timestamps used in Kerberos are encoded as GeneralizedTime. An encoding specifies the
UTC time zone (Z) and cannot include any fractional portions of the seconds. It further
cannot include any separators. Example: The only valid format for UTC time 6 minutes, 27
seconds after 9 PM on 6 November 1985 is 19851106210627Z.
Host Addresses
Kerberos messages usually contain a reference to a specific host, or a list of hosts. That
reference is stored as a host address. A host address is a sequence of components consisting
of the following subfields:
HostAddress = {
addr-type[0] INTEGER,
address[1] BYTE STRING
}
HostAddresses = {
addr-type[0] INTEGER,
address[1] BYTE STRING
}
The host address encoding consists of the following two fields:
606 Part II: Gaining Access and Securing the Gateway
n addr-type. Specifies the type of address that follows.
n address. Encodes a single address of type addr-type.
The two forms differ slightly. HostAddress contains exactly one address. HostAddresses
contains a sequence of possibly many addresses.
Authorization Data
Kerberos messages contain authorization data, which is a sequence of components consisting of
the following subfields:
AuthorizationData = {
ad-type[0] INTEGER,
ad-data[1] BYTE STRING
}
The authorization data encoding consists of the following two fields:
n ad-type. Specifies the format for the ad-data subfield. All negative values are reserved
for local use. Non-negative values are reserved for registered use.
n ad-data. Contains authorization data to be interpreted according to the value of the
corresponding ad-type field.
Last Request Data
As a part of the Authentication Server transaction, a last request field is returned. The contents
of this field should be displayed to users to enable them to detect unauthorized use of their
account. The last request is a sequence of components consisting of the following subfields:
LastReq = {
lr-type[0] INTEGER,
lr-value[1] KerberosTime
}
Table 9.12 describes the fields in this message.
Table 9.12
Last Request Fields
Field Description
lr-type Indicates how the following lr-value field is to be interpreted. Negative values
indicate that the information pertains only to the responding server. Non-negative
values pertain to all servers for the realm.
0 No information conveyed by lr-value subfield.
Kerberos 607
1 Time of last initial request for a Ticket Granting Ticket.
2 Time of last initial request.
3 Time of issue for newest Ticket Granting Ticket used.
4 Time of last renewal.
5 Time of last request of any type.
lr-value Contains the time of the last request. The time must be interpreted according to
the contents of the accompanying lr-type subfield.
Error Message Specification
This section specifies the format for the KRB_ERROR message. The fields included in the
message are intended to return as much information as possible about an error. Don’t expect
all the information required by the fields to be available for all types of errors. If the appropriate
information is not available during composition of the message, the corresponding field is
left out of the message.
Because the KRB_ERROR message is not protected by any encryption, an intruder could
synthesize or modify such a message. In particular, this means that the client should not use
any fields in this message for security-critical purposes, such as setting a system clock or
generating a fresh Authenticator. The message can be useful, however, for advising a user on
the reason for some failure.
KRB_ERROR Definition
The KRB_ERROR message consists of the following fields:
KRB-ERROR = {
pvno[0] INTEGER,
msg-type[1] INTEGER,
ctime[2] KerberosTime OPTIONAL,
cusec[3] INTEGER OPTIONAL,
stime[4] KerberosTime,
susec[5] INTEGER,
error-code[6] INTEGER,
crealm[7] Realm OPTIONAL,
cname[8] PrincipalName OPTIONAL,
realm[9] Realm, — Correct realm
sname[10] PrincipalName, —
Correct name
e-text[11] GeneralString OPTIONAL,
e-data[12] BYTE STRING OPTIONAL
}
Field Description
608 Part II: Gaining Access and Securing the Gateway
Table 9.13 describes the fields in this message.
Table 9.13
KRB_ERROR Field Descriptions
Field Description
pvno and msg-type Described earlier. msg-type is KRB_ERROR.
ctime Described earlier.
cusec Described earlier.
stime Contains the current time on the server, of type KerberosTime.
susec Contains the microsecond part of the server’s timestamp.
error-code Contains the error code returned by Kerberos or the server when a
request fails.
crealm, cname, srealm, Described earlier.
and sname
e-text Contains additional text to help explain the error code associated
with the failed request. It might include, for example, a principal
name that was unknown.
e-data Contains additional data about the error for use by the application
to help it recover from or handle the error. If the errorcode is
KDC_ERR_PREAUTH_REQUIRED, the e-data field contains
an encoding of a sequence of padata fields, each corresponding to
an acceptable preauthentication method and optionally containing
data for the method.
If the error-code is KRB_AP_ERR_METHOD, then the e-data field contains an encoding of
the following sequence:
METHOD-DATA = {
method-type[0] INTEGER,
method-data[1] BYTE STRING OPTIONAL
}
Table 9.14 describes the fields in this option.
Kerberos 609
Table 9.14
Error Method Field Descriptions
Field Description
method-type Indicates the required alternative method.
method-data Contains any required additional information.
Kerberos Workstation Authentication
Problem
Requests for Kerberos Ticket Granting Tickets are sent in plaintext to the Kerberos server,
which responds with credentials encrypted in the requesting principal’s secret key. The
program then attempts to decrypt the data with the supplied password and considers the
authentication “successful” if the decryption appears to yield meaningful results, such as the
correct principal name.
The problem here is that the requesting program cannot know for sure whether the decryption
succeeded or, more importantly, whether the response actually came from the Kerberos server.
An attacker could, for example, walk up to an unattended machine and “log in” as a nonexistent
user. Kerberos eventually responds with an appropriate error, but the attacker can arrange
for another program to deliver a fake response to log in first. He then types the correct
password, which he knows because he created the fake response in the first place, and succeeds
in spoofing login.
The solution to this problem is for login to verify the Ticket Granting Ticket by using it to
acquire a service ticket with a known key and comparing the results. Typically, this means
requesting an rcmd.<hostname> ticket, where <hostname> is the local host name, and checking
the response against the key stored in the machine’s /etc/srvtab file. If the keys match, the
original Ticket Granting Ticket must have come from Kerberos, because the key only exists in
the srvtab and the Kerberos database, and login can permit the user to log in.
The solution works only as long as the host has a srvtab containing an rcmd.<hostname>,
or any other standard principal entry. This is fine for physically secure or single-user workstations,
but does not work on public workstations in which anyone could access the srvtab
file.
Kerberos Port Numbers
The file src/prototypes/services.append in the MIT Kerberos distribution contains the commonly
used port assignments. This file is not the whole story, however. Kerberos has officially
610 Part II: Gaining Access and Securing the Gateway
been moved to port 88, although people will have to listen on port 750 for some time to come
and assume that many servers won’t be converted to listen to port 88 for some time.
“kerberos_master” and “krb_prop” have not been reserved, but they are used only for intra-site
transactions, so having them reserved probably isn’t necessary. Furthermore, both of their port
numbers have already been assigned to other services, so requesting an official assignment
forces them to change.
eklogin, kpop, and erlogin have not been officially reserved, but probably should be. Their
ports currently aren’t assigned to other services, so hopefully they will not have to change if an
official assignment is requested.
Kerberos Telnet
An experimental Telnet Authentication Option has been defined, and is described in
RFC1416. A separate document, RFC1411, describes how that option is to be used with
Kerberos version 4, but no RFC exists for its use with Kerberos version 5. These RFCs define
only how authentication must be performed. The standard for full encryption remains
under development.
An implementation of Kerberos version 4 telnet is available through anonymous FTP from the
following site:
ftp.uu.net/networking/telnet.91.03.25.tar.Z
It predates both of the earlier-mentioned RFCs, however, and therefore almost certainly isn’t
compliant with them. A Kerberos version 5 telnet implementation, based on the 4.4BSD
telnet/telnetd, also exists, but has been temporarily removed from distribution—probably
because it also does not comply with the proposed standards.
Kerberos ftpd
The IETF Common Authentication Technology (CAT) Working Group has published the
Internet Draft “FTP Security Extensions” <draft-ietf-cat-ftpsec-05.txt>, which defines
Kerberos version 4 and GSS-API authentication systems. Source code for a Kerberos version 4
ftp/ftpd with the extensions is available through anonymous FTP from this site:
thumper.bellcore.com:pub/lunt/ftp_ftpd.tar.Z
Kerberos 611
Other Sources of Information
Plenty of Kerberos-related sources are available on the Internet.
The WWW offers much useful information, but it changes frequently enough that listing sites
here would be pointless. The common search engines all list several sites, and most of the sites
point to other useful sites.
The main newsgroup is comp.protocols.kerberos.